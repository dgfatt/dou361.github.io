---
title: Android面试选择题收集
date: 2017-02-13 08:30:00
categories: Android
tags: 
- 面试
- 选择题
description:
img:  

---

1.	什么是B/S架构？什么是C/S架构

	a)	B/S(Browser/Server)，浏览器/服务器程序
	b)	C/S(Client/Server)，客户端/服务端，桌面应用程序

2.	你所知道网络协议有那些？

	a)	HTTP：超文本传输协议
	b)	FTP：文件传输协议
	c)	SMPT：简单邮件协议
	d)	TELNET：远程终端协议
	e)	POP3：邮件读取协议

3.	Java都有那些开发平台？
a)	JAVA SE：主要用在客户端开发
b)	JAVA EE：主要用在web应用程序开发
c)	JAVA ME：主要用在嵌入式应用程序开发
4.	什么是JVM？java虚拟机包括什么？
a)	JVM：java虚拟机，运用硬件或软件手段实现的虚拟的计算机
b)	Java虚拟机包括：寄存器，堆栈，处理器
5.	Java是否需要开发人员回收内存垃圾吗？
a)	大多情况下是不需要的。
b)	Java提供了一个系统级的线程来跟踪内存分配，不再使用的内存区将会自动回收
6.	什么是JDK？什么是JRE?
a)	JDK：java development kit：java开发工具包，是开发人员所需要安装的环境
b)	JRE：java runtime environment：java运行环境，java程序运行所需要安装的环境
7.	什么是数据结构？
a)	计算机保存，组织数据的方式
8.	Java的数据结构有那些？
a)	线性表（ArrayList）
b)	链表（LinkedList）
c)	栈（Stack）
d)	队列（Queue）
e)	图（Map）
f)	树（Tree）
9.	什么是OOP?
a)	面向对象编程
10.	什么是面向对象？
a)	世间万物都可以看成一个对象。每个物体包括动态的行为和静态的属性，这些就构成了一个对象。
11.	类与对象的关系?
a)	类是对象的抽象，对象是类的具体
b)	类是对象的模板，对象是类的实例
12.	Java中有几种数据类型
a)	整形：byte,short,int,long
b)	浮点型：float,double
c)	字符型：char
d)	布尔型：boolean
13.	什么是隐式转换，什么是显式转换
a)	显示转换就是类型强转，把一个大类型的数据强制赋值给小类型的数据
b)	隐式转换就是大范围的变量能够接受小范围的数据
c)	隐式转换和显式转换其实就是自动类型转换和强制类型转换
14.	Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型
a)	Char在java中也是比较特殊的类型，它的int值从1开始，一共有2的16次方个数据
b)	Char<int<long<float<double
c)	Char类型可以隐式转成int,double类型，但是不能隐式转换成string
d)	如果char类型转成byte，short类型的时候，需要强转
15.	什么是拆装箱？
a)	拆箱：把包装类型转成基本数据类型
b)	装箱：把基本数据类型转成包装类型
16.	Java中的包装类都是那些？
a)	byte：Byte
b)	short：Short
c)	int：Integer
d)	long：Long
e)	float：Float
f)	double：Double
g)	char：Character
h)	boolean：Boolean
17.	一个java类中包含那些内容？
a)	属性
b)	方法
c)	内部类
d)	构造方法
e)	代码块
18.	例如： if(a+1.0=4.0)，这样做好吗？
a)	不好，因为计算机在浮点型数据运算的时候，会有误差，尽量在布尔表达式中不使用浮点型数据(if,while,switch中判断条件不使用浮点型)
19.	那针对浮点型数据运算出现的误差的问题，你怎么解决？
a)	使用Bigdecimal类进行浮点型数据的运算
20.	++i与i++的区别
a)	++i：先赋值，后计算
b)	i++：先计算，后赋值
21.	程序的结构有那些？
a)	顺序结构
b)	选择结构
c)	循环结构
22.	数组实例化有几种方式？
a)	静态实例化：创建数组的时候已经指定数组中的元素,int[] a=new int[]{1,3,3}
b)	动态实例化：实例化数组的时候，只指定了数组程度，数组中所有元素都是数组类型的默认值
23.	Java中各种数据默认值
a)	Byte,short,int,long默认是都是0
b)	Boolean默认值是false
c)	Char类型的默认值是’’
d)	Float与double类型的默认是0.0
e)	对象类型的默认值是null
24.	Java常用包有那些？
a)	Java.lang
b)	Java.io
c)	Java.sql
d)	Java.util
e)	Java.awt
f)	Java.net
g)	Java.math
25.	Java最顶级的父类是哪个？
a)	Object
26.	Object类常用方法有那些？
a)	Equals
b)	Hashcode
c)	toString
d)	wait
e)	notify
f)	clone
g)	getClass
27.	java中有没有指针？
a)	有指针，但是隐藏了，开发人员无法直接操作指针，由jvm来操作指针
28.	java中是值传递引用传递？
a)	理论上说，java都是引用传递，对于基本数据类型，传递是值的副本，而不是值本身。
b)	对于对象类型，传递是对象的引用，当在一个方法操作操作参数的时候，其实操作的是引用所指向的对象。
29.	假设把实例化的数组的变量当成方法参数，当方法执行的时候改变了数组内的元素，那么在方法外，数组元素有发生改变吗？
a)	改变了，因为传递是对象的引用，操作的是引用所指向的对象
30.	实例化数组后，能不能改变数组长度呢？
a)	不能，数组一旦实例化，它的长度就是固定的
31.	假设数组内有5个元素，如果对数组进行反序，该如何做？
a)	创建一个新数组，从后到前循环遍历每个元素，将取出的元素依次顺序放入新数组中
32.	形参与实参
a)	形参：全称为“形式参数”，是在定义方法名和方法体的时候使用的参数，用于接收调用该方法时传入的实际值
b)	实参：全称为“实际参数”，是在调用方法时传递给该方法的实际值
33.	构造方法能不能显式调用？
a)	不能构造方法当成普通方法调用，只有在创建对象的时候它才会被系统调用
34.	构造方法能不能重写？能不能重载？
a)	可以重写，也可以重载
35.	什么是方法重载？
a)	方法的重载就是在同一个类中允许同时存在一个以上的同名方法，只要它们的参数个数或者类型不同即可。在这种情况下，该方法就叫被重载了，这个过程称为方法的重载（override）
36.	内部类与静态内部类的区别？
a)	静态内部类相对与外部类是独立存在的，在静态内部类中无法直接访问外部类中变量、方法。如果要访问的话，必须要new一个外部类的对象，使用new出来的对象来访问。但是可以直接访问静态的变量、调用静态的方法
b)	普通内部类作为外部类一个成员而存在，在普通内部类中可以直接访问外部类属性，调用外部类的方法。
c)	如果外部类要访问内部类的属性或者调用内部类的方法，必须要创建一个内部类的对象，使用该对象访问属性或者调用方法。
d)	如果其他的类要访问普通内部类的属性或者调用普通内部类的方法，必须要在外部类中创建一个普通内部类的对象作为一个属性，外同类可以通过该属性调用普通内部类的方法或者访问普通内部类的属性
e)	如果其他的类要访问静态内部类的属性或者调用静态内部类的方法，直接创建一个静态内部类对象即可。
37.	Static关键字有什么作用？
a)	Static可以修饰内部类、方法、变量、代码块
b)	Static修饰的类是静态内部类
c)	Static修饰的方法是静态方法，表示该方法属于当前类的，而不属于某个对象的，静态方法也不能被重写，可以直接使用类名来调用。在static方法中不能使用this或者super关键字。
d)	Static修饰变量是静态变量或者叫类变量，静态变量被所有实例所共享，不会依赖于对象。静态变量在内存中只有一份拷贝，在JVM加载类的时候，只为静态分配一次内存。
e)	Static修饰的代码块叫静态代码块，通常用来做程序优化的。静态代码块中的代码在整个类加载的时候只会执行一次。静态代码块可以有多个，如果有多个，按照先后顺序依次执行。
38.	Final在java中的作用
a)	Final可以修饰类，修饰方法，修饰变量。
b)	修饰的类叫最终类。该类不能被继承。
c)	修饰的方法不能被重写。
d)	修饰的变量叫常量，常量必须初始化，一旦初始化后，常量的值不能发生改变。
39.	Java中操作字符串使用哪个类？
a)	String，StringBuffer，StringBuilder
40.	StringBuffer，Stringbuilder有什么区别？
a)	StringBuffer与StringBuilder都继承了AbstractStringBulder类，而AbtractStringBuilder又实现了CharSequence接口，两个类都是用来进行字符串操作的。
b)	在做字符串拼接修改删除替换时，效率比string更高。
c)	StringBuffer是线程安全的，Stringbuilder是非线程安全的。所以Stringbuilder比stringbuffer效率更高，StringBuffer的方法大多都加了synchronized关键字
41.	String str=”aaa”,与String str=new String(“aaa”)一样吗？
a)	不一样的。因为内存分配的方式不一样。
b)	第一种，创建的”aaa”是常量，jvm都将其分配在常量池中。
c)	第二种创建的是一个对象，jvm将其值分配在堆内存中。
42.	String str=”aa”,String s=”bb”,String aa=aa+s;一种创建了几个对象？
a)	一共有两个引用，三个对象。因为”aa”与”bb”都是常量，常量的值不能改变，当执行字符串拼接时候，会创建一个新的常量是” aabbb”,有将其存到常量池中。
43.	将下java中的math类有那些常用方法？
a)	Pow()：幂运算
b)	Sqrt()：平方根
c)	Round()：四舍五入
d)	Abs()：求绝对值
e)	Random()：生成一个0-1的随机数，包括0不包括1
44.	String类的常用方法有那些？
a)	charAt：返回指定索引处的字符
b)	indexOf()：返回指定字符的索引
c)	replace()：字符串替换
d)	trim()：去除字符串两端空白
e)	split()：分割字符串，返回一个分割后的字符串数组
f)	getBytes()：返回字符串的byte类型数组
g)	length()：返回字符串长度
h)	toLowerCase()：将字符串转成小写字母
i)	toUpperCase()：将字符串转成大写字符
j)	substring()：截取字符串
k)	format()：格式化字符串
l)	equals()：字符串比较
45.	判断两个对象是否相同，能使用equlas比较吗？
a)	不能。Equlas大多用来做字符串比较，要判断基本数据类型或者对象类型，需要使用==
46.	==与equlas有什么区别？
a)	==可以判断基本数据类型值是否相等，也可以判断两个对象指向的内存地址是否相同，也就是说判断两个对象是否是同一个对象
b)	Equlas通常用来做字符串比较
47.	如何将字符串反转？
a)	Stringbuilder或者stringbuffer的reverse方法
48.	面向对象的语言有那些特征？
a)	封装
b)	继承
c)	多态
49.	Java中的继承是单继承还是多继承
a)	Java中既有单继承，又有多继承。
b)	对于java类来说只能有一个父类，对于接口来说可以同时继承多个接口
50.	什么是重写？什么是重载？
a)	重载和重写都是java多态的表现。
b)	重载叫override，在同一个类中多态的表现。当一个类中出现了多个相同名称的方法，但参数个数和参数类型不同，方法重载与返回值无关
c)	重写叫overwrite，是字符类中多态的表现。当子类出现与父类相同的方法，那么这就是方法重写。方法重写时，子类的返回值必须与父类的一致。如果父类方法抛出一个异常，子类重写的方法抛出的异常类型不能小于父类抛出的异常类型。
51.	构造方法能不能重载？能不能重写？
a)	可以重载，必须重写
52.	如果父类只有有参构造方法，那么子类必须要重写父类的构造方法吗？
a)	必须重写
53.	创建一个子类对象的时候，那么父类的构造方法会执行吗？
a)	会执行。当创建一个子类对象，调用子类构造方法的时候，子类构造方法会默认调用父类的构造方法。
54.	什么是父类引用指向子类对象？
a)	是java多态一种特殊的表现形式。创建父类引用，让该引用指向一个子类的对象
55.	当父类引用指向子类对象的时候，子类重写了父类方法和属性，那么当访问属性的时候，访问是谁的属性？调用方法时，调用的是谁的方法？
a)	子类重写了父类方法和属性，访问的是父类的属性，调用的是子类的方法
56.	Super与this表示什么？
a)	Super表示当前类的父类对象
b)	This表示当前类的对象
57.	抽象的关键字是什么？ 
a)	Abstract
58.	抽象类必须要有抽象方法吗
a)	不是必须。抽象类可以没有抽象方法。
59.	如果一个类中有抽象方法，那么这个一定是抽象类？
a)	包含抽象方法的类一定是抽象类
60.	抽象类可以使用final修饰吗？
a)	不可以。定义抽象类就是让其他继承的，而final修饰类表示该类不能被继承，与抽象类的理念违背了
61.	普通类与抽象类有什么区别？
a)	普通类不能包含抽象方法，抽象类可以包含抽象方法
b)	抽象类不能直接实例化，普通类可以直接实例化
62.	什么是接口？ 
a)	接口就是某个事物对外提供的一些功能的声明，是一种特殊的java类
63.	JAVA为什么需要接口？
a)	接口弥补了java单继承的缺点
64.	接口有什么特点？
a)	接口中声明全是public static final修饰的常量
b)	接口中所有方法都是抽象方法
c)	接口是没有构造方法的
d)	接口也不能直接实例化
e)	接口可以多继承
65.	接口与抽象类有什么区别？
a)	抽象类有构造方法，接口没有构造方法
b)	抽象类只能单继承，接口可以多继承
c)	抽象类可以有普通方法，接口中的所有方法都是抽象方法
d)	接口的属性都是public static final修饰的，而抽象的不是
66.	Java中异常分为哪两种？
a)	编译时异常
b)	运行时异常
67.	说几个常见的编译时异常类？
a)	NullPointerException：空指针异常
b)	ArrayIndexOutOfBoundsException：数组下标越界
c)	NumberFormatException：数字转换异常
d)	IllegalArgumentException：参数不匹配异常
e)	InstantiationException：对象初始化异常
f)	ArithmeticException：算术异常
68.	异常的处理机制有几种？
a)	异常捕捉：try…catch…finally
b)	异常抛出：throws
69.	如何自定义一个异常
a)	继承一个异常类，通常是RumtimeException或者Exception
70.	在异常捕捉时，如果发生异常，那么try.catch.finally块外的return语句会执行吗？
a)	会执行，如果有finally，在finally之后被执行，如果没有finally，在catch之后被执行
71.	Try.catch.finally是必须要存在的吗？
a)	Try块必须存在，catch和finally可以不存在，但不能同时不存在
72.	Thow与thorws区别
a)	Throw写在代码块内，throw后面跟的是一个具体的异常实例
b)	Throw写在方法前面后面，throws后面跟的是异常类，异常类可以出现多个
73.	Error与Exception区别？
a)	Error和Exception都是java错误处理机制的一部分，都继承了Throwable类。
b)	Exception表示的异常，异常可以通过程序来捕捉，或者优化程序来避免。
c)	Error表示的是系统错误，不能通过程序来进行错误处理。
74.	使用Log4j对程序有影响吗？
a)	有，log4j是用来日志记录的，记录一些关键敏感的信息，通常会将日志记录到本地文件或者数据库中。记录在本地文件中，会有频繁的io操作，会耗费一些系统资源。记录在数据库中，会频繁地操作数据库表，对系统性能也有一定的影响。但是为了程序安全以及数据的恢复或者bug的跟踪，这点资源消耗是可以承受的。
75.	Log4j日志有几个级别？
a)	由低到高：debug、info、wran、error
76.	除了使用new创建对象之外，还可以用什么方法创建对象？
a)	Java反射
77.	Java反射创建对象效率高还是通过new创建对象的效率高？
a)	通过new创建对象的效率比较高。通过反射时，先找查找类资源，使用类加载器创建，过程比较繁琐，所以效率较低
78.	Java中集合框架的有几个？
a)	Coillection
b)	Map
79.	Collection接口下有那些集合框架？
a)	List：线性表
b)	Set：无序集合
80.	List接口有什么特点？
a)	顺序存储
b)	可以有重复值
81.	Set接口有什么特点
a)	无须存储
b)	不能有重复值
82.	ArrayList与LinkedList有什么区别？
a)	ArrayList与LinkedList都实现了List接口。
b)	ArrayList是线性表，底层是使用数组实现的，它在尾端插入和访问数据时效率较高， 
c)	Linked是双向链表，他在中间插入或者头部插入时效率较高，在访问数据时效率较低
83.	Array与ArrayList有什么不一样？
a)	Array与ArrayList都是用来存储数据的集合。
b)	ArrayList底层是使用数组实现的，但是arrayList对数组进行了封装和功能扩展，拥有许多原生数组没有的一些功能。我们可以理解成ArrayList是Array的一个升级版。
84.	Map有什么特点
a)	以键值对存储数据
b)	元素存储循序是无须的
c)	不允许出现重复键
85.	JDBC操作的步骤
a)	加载数据库驱动类
b)	打开数据库连接
c)	执行sql语句
d)	处理返回结果
e)	关闭资源
86.	在使用jdbc的时候，如何防止出现sql注入的问题。
a)	使用PreparedStatement类，而不是使用Statement类
87.	怎么在JDBC内调用一个存储过程
a)	使用CallableStatement
88.	是否了解连接池，使用连接池有什么好处？
a)	数据库连接是非常消耗资源的，影响到程序的性能指标。连接池是用来分配、管理、释放数据库连接的，可以使应用程序重复使用同一个数据库连接，而不是每次都创建一个新的数据库连接。通过释放空闲时间较长的数据库连接避免数据库因为创建太多的连接而造成的连接遗漏问题，提高了程序性能。
89.	你所了解的数据源技术有那些？使用数据源有什么好处？
a)	Dbcp,c3p0等，用的最多还是c3p0，因为c3p0比dbcp更加稳定，安全
b)	通过配置文件的形式来维护数据库信息，而不是通过硬编码。当连接的数据库信息发生改变时，不需要再更改程序代码就实现了数据库信息的更新。
90.	Java的io流分为哪两种？
a)	按功能来分
i.	输入流(input)，输出流(output)
b)	按类型来分
i.	字节流，字符流
91.	常用io类有那些？
a)	File
b)	FileInputSteam，FileOutputStream
c)	BufferInputStream，BufferedOutputSream
d)	PrintWrite
e)	FileReader，FileWriter
f)	BufferReader，BufferedWriter
g)	ObjectInputStream，ObjectOutputSream
92.	字节流与字符流的区别
a)	以字节为单位输入输出数据，字节流按照8位传输
b)	以字符为单位输入输出数据，字符流按照16位传输
93.	Javascript中常用的事件有哪些？
a)	Onsubmit：提交
b)	Onblur：失去焦点
c)	Onclick：单击
d)	Onload：加载页面
e)	Onchange：内容改变
f)	onMouseMove：鼠标移动
g)	onMouseOver：鼠标经过
h)	onMouseOut：鼠标移出
i)	onselect：下拉选项被选中
94.	js如何实现页面刷新呢？
a)	history.go(0)
b)	location.reload()
95.	页面前进或者后退
a)	前进
i.	history.go(1)
ii.	history.forward
b)	后退
i.	History.go(-1)
ii.	History.back
96.	Js如何跳转到到一个指定页面
a)	Location.href=url
b)	History.go(url)
97.	使用js获取一个表单元素
a)	Document.getElementById()
b)	Document.getElementsByName()
c)	Document.getElementsByTagName()
98.	如何阻止表单提交
a)	Onsubmit=“return false”
99.	正则表达式有那些符号？
a)	$：匹配字符串结束的位置
b)	^：匹配字符串开始的位置
c)	*：匹配零次或者多次
d)	+：匹配至少一次
e)	?：匹配零次或者一次
f)	.：匹配除换行符 \n之外的任何单字符
g)	{n}：n 是一个非负整数，匹配确定的 n 次 
h)	{n,m}：m 和 n 均为非负整数，表示最多和最少匹配次数，其中n <= m 
i)	\w：匹配单个字符(a-z,0-9,_)
j)	\W：与\w相反
k)	\d：匹配数字
l)	\D：与\d相反
100.	Sql中delete与truncate的区别
a)	DELETE：选择性地删除数据，当删除整张表的数据时效率较低
b)	只能删除整张表的数据，但是效率高于使用DELETE语句；不能选择性地删除。当truncate执行删除之后，自动生成的主键值重新从默认值开始
101.	Xml的java解析有几种方式？
a)	Java API解析xml有两种方式
i.	Dom解析：一次性加载整个文档，生成树形结构。在生成的文档对象中，可以对节点进行增删改查的操作。当xml文本当较小的时候，可以使用dom解析。
ii.	Sax解析：基于事件的解析方式，解析速度比较快，解析的文档大小理论上是没有限制的。
iii.	还有一些开源的技术可以解析xml，dom4j或者jdom。
102.	Sql优化有那些方法？
103.	Json是什么？ 
a)	Json（javascript simple object notation）：轻量级的数据交换格式。
104.	如何创建一个json对象？
a)	使用{}实例化一个json对象，json对象多个元素使用逗号隔开，每个元素都是一个键值对
105.	如何解析json对象？
a)	使用json-lib、gson、jackson可以解析json对象。需要将json对象转换成一个java对象，使用java对象访问属性。
106.	聚集索引与非聚集索引有什么区别？
a)	所有的索引都是为了更快地检索数据，索引存放在索引页中，数据存放在数据页中，索引以B（balance）树的形式存储
b)	聚集索引：聚集索引用于决定数据表中的物理存储顺序，一张表最多有一个聚集索引。聚集索引的字段值尽量不能修改，因为修改后，因为修改后数据表的物理顺序需要重写排序。通常主键就是聚集索引
c)	非聚集索引：非聚集索引的关键自是index，不会决定表的物理存储顺序，在一张表内最多可以有249个非聚集索引。
107.	一个类文件中能否有多个类？有什么要求？
a)	可以。但是只能有一个public类，而且public修饰的类名与文件名必须一致
108.	你知道有哪些开源框架？
a)	Poi：操作office文档
b)	Jfreechat：生成各种图表
c)	Ckeditor：论坛中的富文本输入框
d)	Lucena：用于搜索技术
e)	Pinyin4j：操作汉字的拼音
109.	什么是事务？事务有那些特点？
a)	事务：单个逻辑单元执行的一系列操作，要么全部执行，要么全部不执行。
b)	特点：
i.	原子性（Atomicity）：事务中各元素不可分割，全部执行成功或者撤销所有的操作
ii.	一致性（Consistency）：事务完成后数据保持一致的状
iii.	隔离性（Isolation）：事务是相对独立的，对某数据进行修改时，其他事务不变 
iv.	持久性（Durability）：事务完成后对系统的影响是永久性的。
110.	事务的使用场景在什么地方？
a)	但一个业务逻辑包括多个数据库操作的时候，而且需要保证每个数据表操作都执行的成功进行下一个操作，这个时候可以使用事务
111.	Js如何实现动态效果？
a)	操作dom，改变dom的结构
112.	Jsp由哪些内容组成？
a)	指令：<%@ %>
b)	脚本：<% %>
c)	表达式：<%=%>
d)	声明：<%! %>
e)	注释：<% -- %>
f)	动作：<jsp：动作名称 属性=””>
g)	静态内容：html内容
113.	Jsp包含那些隐藏对象或者内建对象
a)	Page
b)	pageContext
c)	request
d)	response
e)	out
f)	session
g)	application
h)	config
i)	exception
114.	如何使用exception对象？
a)	用于处理JSP文件执行时发生的所有错误和异常，只有在page指令中设置isErrorPage值为true的页面中才可以被使用，在一般的JSP页面中使用该对象，将无法编译JSP文件。 
115.	Get请求与post有什么区别？
a)	Get请求发送的文本内容大小有限制，而post请求没有限制
b)	Get请求的请求参数会出现在url路径中，而发送post请求时，参数不会显示在url路径中
c)	Get安全系数较低，但是效率较高。Post安全系数较高，但效率较低
d)	Get请求只能发送字符串，post请求可以提交二进制数据
116.	计算机网络有几层？
a)	应用层
b)	表示层
c)	会话层
d)	传输层
e)	网络层
f)	数据链路层
g)	物理层
h)	（物理层是最底层，应用层是最高层）
117.	常见的计算机网络协议有那些？
a)	TCP/IP协议
b)	IPX/SPX协议
c)	NetBEUI协议
118.	Tcp协议的特点
a)	TCP 是面向连接的传输层协议 
b)	每一条 TCP 连接只能有两个端点(endpoint),每一条 TCP 连接只能是点对点的（一对一） 
c)	TCP 提供可靠交付的服务 
d)	TCP 提供全双工通信
e)	面向字节流
119.	Java网络编程有几种？
a)	TCP编程
b)	UDP编程
120.	TCP编程与UDP编程有什么区别？
a)	TCP协议：传输控制协议，提供可靠无差错的数据传输，效率较低
b)	UDP协议：用户数据报协议，不可靠的数据传输，效率较高
121.	创建socket通讯的步骤？
a)	服务器程序创建一个ServerSocket，然后再用accept方法等待客户来连接
b)	客户端程序创建一个Socket并请求与服务器建立连接
c)	服务器接收客户的连接请求,并创建一个新的Socket与该客户建立专线连接
d)	刚才建立了连接的两个Socket在一个线程上对话
e)	服务器开始等待新的连接请求`
122.	Java中如何实现多线程
a)	继承Thread类
b)	实现Runnable接口
c)	推荐使用Runnable接口
123.	Java中Synchronized关键字的使用？
a)	Synchronized关键字在方法签名上，可以防止多个线程同时访问这个对象的synchronized修饰的方法。如果一个对象有多个synchronized方法，只要一个线程访问其中的一个同步方法，那么其他线程就不能访问对象其他的任何一个同步方法。不同对象实例的synchronize方法是互不干扰的，也就是说，其他对象还可以访问这个类中的同步方法。
b)	Synchronized如果修饰的是静态方法，防止多个线程同时访问这个类中的静态同步方法，它对类中所有对象都能起作用。也就是说，只有一个对象一个线程可以访问静态同步方法
c)	Synchronized修饰方法中的某段代码块，只对当前代码块实行互斥访问。当多个线程同步访问同步代码块，同一时间只能有一个线程得到执行，其他线程必须等待当前线程执行完代码块之后才能执行。当一个线程访问同步代码快时，其他线程可以访问非同步的代码。当一个线程访问同步代码块时，那么其他线程访问对其他同步代码块的访问将会被阻塞
d)	Synchronized关键字是不能继承的，如果父类的synchronized在继承时并不自动是synchronized修饰的，需要显示地声明。
e)	Synchronized修饰this时，会得到这个对象的对象锁，当一个线程访问时，那么其他线程访问对象的所有同步代码块或者同步方法，将会被阻塞。
124.	什么是线程池？
a)	在一个应用程序中初始化一个线程集合，然后在需要执行新的任务时重用线程池中的线程，而不是创建一个新的线程。线程池中的每个线程都有被分配一个任务，一旦任务完成，线程就回到线程池中，等待下一次的任务分配
125.	什么是游标？ 
a)	游标是sql查询结果集的一个指针，与select语句相关联。
b)	游标关键字是cursor，主要包含两个部分：游标结果集和游标位置。
i.	游标结果集：执行select语句后的查询结果
ii.	游标位置：一个指向游标结果集内某条记录的指针。
c)	游标主要有两个状态：打开和关闭。
i.	只有当游标处于打开状态时，才能够操作结果集中的数据
ii.	当游标关闭后，查询结果集就不存在了
126.	游标的创建步骤？
a)	定义游标
b)	打开游标
c)	操作游标数据
d)	关闭游标
127.	在做文件上传的时候，form表单的enctype的指是什么？
a)	Mulitipart/form-data
128.	Html中a标签的target属性有哪些值？
a)	_blank：在新的窗口打开网页
b)	_self：在本页面打开新网页
c)	_parent：在父frameset框架打开网页
d)	_top：去掉所有页面框架，使用document.htnl替代frameset文档
129.	当打开其他程序的网页时，使用的target属性是哪个？
a)	_top
130.	Servlet的生命周期？
a)	加载：判断servlet实例是否存在，如果不存在，就加载serlvet
b)	实例化：
c)	初始化
d)	服务
e)	销毁
131.	Servlet生命周期内调用的方法过程？
a)	Init()
b)	Service()
c)	doGet或者doPost
d)	destroy
132.	线程的生命周期？
a)	新建
b)	就绪
c)	运行
d)	死亡
e)	阻塞
133.	Statement与preparedStatement区别
a)	preparedStatement会预编译sql语句，能够提高批量的数据操作的执行效率，Statement执行slq的时候才进行编译
b)	Preparedstatement在第一次执行sql的时候，比较耗费资源。如果只对数据库进行一次操作，使用statement比较好。
c)	Statement会出现sql注入的问题，使用preparedstatment可以解决sql注入
134.	Session与cookie的区别？
a)	Session保存在服务端，cookie保存在客户端
b)	Session保存是对象，cookie只能保存字符串
c)	Session不能设置路径，cookie可以设置保存路径。同一个网站不同网页的cookie可以保存到不通的路机构下，彼此是无法相互访问的。
d)	Session在服务器关闭后会自动消失，cookie则不会。
135.	存储过程与函数的区别
a)	存储过程的关键自是procedure，函数关键字是function
b)	函数必须有返回值，存储过程没有返回值，但是有传出参数
c)	函数注重的是结果，存储过程注重的是过程
d)	函数可以在select语句中直接使用，而存储过程则不能
136.	会话跟踪技术有那些？
a)	Session
b)	Cookie
c)	表单隐藏域
d)	url重写
137.	jspservlet中通信作用域有那些？
a)	PageContext
b)	Request
c)	Session
d)	Application
138.	url是什么？由哪些部分组成？
a)	统一资源定位符
b)	http://localhost:8080/myWeb/index.html：协议+主机地址+端口+项目名称+资源名称
139.	你所知道的web服务器有哪些？
a)	Tomcat
b)	Jboss
c)	Weblogic
d)	Glassfish
140.	如何部署一个web项目？
a)	可以将web项目打包成.war文件
b)	把war文件放在webapps文件夹中
141.	如何修改tomcat的端口号？
a)	在tomcat根目录的conf文件夹内打开server.xml文件，修改Connector节点的port属性
142.	重定向和请求转发的区别？
a)	请求转发只能将请求转发给同一个Web应用中的其他资源，而重定向不仅可以定向到当前应用程序中的其他资源，也可以重定向到其他站点上的资源。
b)	重定向结束后，浏览器地址栏显示URL会发生改变，由初始的URL地址变成重定向的目标URL。而请求转发过程结束后，浏览器地址栏保持初始的URL地址不变。
c)	请求转发的发起者和接受者之间共享相同的HttpServletRequest实例和HttpServletResponse实例，而重定向的发起者和接受者使用各自的HttpServletRequest实例和HttpServletResponse实例。
d)	转发是一次请求，重定向是二次请求。转发是在服务器进行的，重定向在客服端进行的。
143.	上传文件是如何做的？
a)	上传文件主要用的是开源组件，如apache commoms fileupload或者jspformatupload
144.	HTTP的状态码
a)	200：请求成功
b)	400：不是正确的请求，大多情况下表示参数错误
c)	404：找不到请求资源
d)	500：服务器内部错误
e)	403：服务器拒绝
f)	405：请求的method不支持
g)	504：服务器临时不可用
145.	Jsp指令有那些？
a)	Include
b)	Taglib
c)	Page
146.	如何使session失效
a)	Session.invalidate()
147.	如何在jsp页面上显示一些特定格式的数字或者日期
a)	使用jstl标签库，使用numberformat或者dateformat标签
148.	什么是线程异步？什么是线程同步？
a)	线程同步：同时只有一条线程执行一个任务
b)	线程异步：同时有多条线程可以执行执行任务
149.	什么是同步任务？什么是异步任务？
a)	同步任务：当前任务没有完成之前，其他任务不能够执行
b)	异步任务：当前任务没有完成，任然可以可以发送一个新的请求
150.	什么是过滤器？怎么创建一个过滤器
a)	过滤器：在请求发送之后，处理之前对请求的一次拦截，可以更改请求状态或者参数值等。
b)	创建过滤器：
i.	实现filter接口，重写doFilter方法，最后在web.xml中配置过滤器
151.	Int与integer的区别
a)	Integer是int的包装类型。
b)	Int的默认值是0，integer的默认值是null
152.	如何进行单元测试
a)	使用junit
153.	使用sql写出一个分页程序？
a)	Select top 3 * from tb_name where id not in (select top 3 id from tb_name)
154.	监听器有哪些作用和用法？
a)	ava Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示：  
i.	①ServletContextListener：对Servlet上下文的创建和销毁进行监听。  
ii.	②ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。  
iii.	③HttpSessionListener：对Session的创建和销毁进行监听。
155.	JSP中的静态包含和动态包含有什么区别？
a)	静态包含是通过JSP的include指令包含页面，动态包含是通过JSP标准动作<jsp:forward>包含页面。
b)	静态包含是编译时包含，如果包含的页面不存在则会产生编译错误，而且两个页面的"contentType"属性应保持一致，因为两个页面会合二为一，只产生一个class文件，因此被包含页面发生的变动再包含它的页面更新前不会得到更新。
c)	动态包含是运行时包含，可以向被包含的页面传递参数，包含页面和被包含页面是独立的，会编译出两个class文件，如果被包含的页面不存在，不会产生编译错误，也不影响页面其他部分的执行。
156.	Servlet中如何获取用户提交的查询参数或表单数据？
a)	可以通过请求对象（HttpServletRequest）的getParameter()方法通过参数名获得参数值。如果有包含多个值的参数（例如复选框），可以通过请求对象的getParameterValues()方法获得。当然也可以通过请求对象的getParameterMap()获得一个参数名和参数值的映射（Map）。
157.	如何设置请求的编码以及响应内容的类型？
a)	通过请求对象（ServletRequest）的setCharacterEncoding(String)方法可以设置请求的编码，其实要彻底解决乱码问题就应该让页面、服务器、请求和响应、Java程序都使用统一的编码，最好的选择当然是UTF-8；通过响应对象（ServletResponse）的setContentType(String)方法可以设置响应内容的类型，当然也可以通过HttpServletResponsed对象的setHeader(String, String)方法来设置。
158.	什么是Web Service（Web服务）
a)	从表面上看，Web Service就是一个应用程序，它向外界暴露出一个能够通过Web进行调用的API。这就是说，你能够用编程的方法透明的调用这个应用程序，不需要了解它的任何细节，跟你使用的编程语言也没有关系。例如可以创建一个提供天气预报的Web Service，那么无论你用哪种编程语言开发的应用都可以通过调用它的API并传入城市信息来获得该城市的天气预报。之所以称之为Web Service，是因为它基于HTTP协议传输数据，这使得运行在不同机器上的不同应用无须借助附加的、专门的第三方软件或硬件，就可相互交换数据或集成。
159.	什么是ORM？
a)	对象关系映射（Object-Relational Mapping，简称ORM）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术
160.	Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？
a)	SessionFactory对应Hibernate的一个数据存储的概念，它是线程安全的，可以被多个线程并发访问。SessionFactory一般只会在启动的时候构建。对于应用程序，最好将SessionFactory通过单例模式进行封装以便于访问。Session是一个轻量级非线程安全的对象（线程间不能共享session），它表示与数据库进行交互的一个工作单元。Session是由SessionFactory创建的，在任务完成之后它会被关闭。Session是持久层服务对外提供的主要接口。Session会延迟获取数据库连接（也就是在需要的时候才会获取）。为了避免创建太多的session，可以使用ThreadLocal将session和当前线程绑定在一起，这样可以让同一个线程获得的总是同一个session。Hibernate 3中SessionFactory的getCurrentSession()方法就可以做到。
161.	Hibernate中Session的load和get方法的区别是什么？
a)	如果没有找到符合条件的记录，get方法返回null，load方法抛出异常。
b)	get方法直接返回实体类对象，load方法返回实体类对象的代理。
c)	在Hibernate 3之前，get方法只在一级缓存中进行数据查找，如果没有找到对应的数据则越过二级缓存，直接发出SQL语句完成数据读取；load方法则可以从二级缓存中获取数据；从Hibernate 3开始，get方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。
162.	Hibernate的对象有几种状态
a)	瞬时态（transient）
b)	持久态（persistent）
c)	游离态（detached）
163.	Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？
a)	瞬时态的实例可以通过调用save()、persist()或者saveOrUpdate()方法变成持久态；游离态的实例可以通过调用 update()、saveOrUpdate()、lock()或者replicate()变成持久态。save()和persist()将会引发SQL的INSERT语句，而update()或merge()会引发UPDATE语句。save()和update()的区别在于一个是将瞬时态对象变成持久态，一个是将游离态对象变为持久态。merge()方法可以完成save()和update()方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。
b)	对于persist()方法，
i.	persist()方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到flush的时间；
ii.	persist()方法保证当它在一个事务外部被调用的时候并不触发一个INSERT语句，当需要封装一个长会话流程的时候，persist()方法是很有必要的；
iii.	save()方法不保证第②条，它要返回标识符，所以它会立即执行INSERT语句，不管是在事务内部还是外部。至于lock()方法和update()方法的区别，update()方法是把一个已经更改过的脱管状态的对象变成持久状态；lock()方法是把一个没有更改过的脱管状态的对象变成持久状态。
164.	Session加载实体对象的过程。
a)	Session在调用数据库查询功能之前，首先会在一级缓存中通过实体类型和主键进行查找，如果一级缓存查找命中且数据状态合法，则直接返回；
b)	如果一级缓存没有命中，接下来Session会在当前NonExists记录（相当于一个查询黑名单，如果出现重复的无效查询可以迅速做出判断，从而提升性能）中进行查找，如果NonExists中存在同样的查询条件，则返回null；
c)	如果一级缓存查询失败则查询二级缓存，如果二级缓存命中则直接返回；  
d)	如果之前的查询都未命中，则发出SQL语句，如果查询未发现对应记录则将此次查询添加到Session的NonExists中加以记录，并返回null；
e)	根据映射配置和SQL语句得到ResultSet，并创建对应的实体对象； 
f)	将对象纳入Session（一级缓存）的管理；
g)	如果有对应的拦截器，则执行拦截器的onLoad方法； 
h)	如果开启并设置了要使用二级缓存，则将数据对象纳入二级缓存；
i)	返回数据对象。
165.	Query接口的list方法和iterate方法有什么区别？
a)	list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。
b)	list()方法不会引起N+1查询问题，而iterate()方法可能引起N+1查询问题
166.	如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？
a)	延迟加载就是并不是在读取的时候就把数据加载进来，而是等到使用时再加载。Hibernate使用了虚拟代理机制实现延迟加载，我们使用Session的load()方法加载数据或者一对多关联映射在使用延迟加载的情况下从一的一方加载多的一方，得到的都是虚拟代理，简单的说返回给用户的并不是实体本身，而是实体对象的代理。代理对象在用户调用getter方法时才会去数据库加载数据。但加载数据就需要数据库连接。而当我们把会话关闭时，数据库连接就同时关闭了。
b)	延迟加载与session关闭的矛盾一般可以这样处理：
i.	关闭延迟加载特性。这种方式操作起来比较简单，因为Hibernate的延迟加载特性是可以通过映射文件或者注解进行配置的，但这种解决方案存在明显的缺陷。首先，出现"no session or session was closed"通常说明系统中已经存在主外键关联，如果去掉延迟加载的话，每次查询的开销都会变得很大。
ii.	在session关闭之前先获取需要查询的数据，可以使用工具方法Hibernate.isInitialized()判断对象是否被加载，如果没有被加载则可以使用Hibernate.initialize()方法加载对象。
iii.	使用拦截器或过滤器延长Session的生命周期直到视图获得数据。Spring整合Hibernate提供的OpenSessionInViewFilter和OpenSessionInViewInterceptor就是这种做法。
167.	简述Hibernate常见优化策略。
a)	制定合理的缓存策略（二级缓存、查询缓存）。
b)	采用合理的Session管理机制。
c)	尽量使用延迟加载特性。
d)	设定合理的批处理参数。
e)	如果可以，选用UUID作为主键生成器。
f)	如果可以，选用乐观锁替代悲观锁。
g)	在开发过程中, 开启hibernate.show_sql选项查看生成的SQL，从而了解底层的状况；开发完成后关闭此选项。
h)	考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观的提升，但这些需要专业的DBA（数据库管理员）提供支持。
168.	谈一谈Hibernate的一级缓存、二级缓存和查询缓存。
a)	Hibernate的Session提供了一级缓存的功能，默认总是有效的，当应用程序保存持久化实体、修改持久化实体时，Session并不会立即把这种改变提交到数据库，而是缓存在当前的Session中，除非显示调用了Session的flush()方法或通过close()方法关闭Session。通过一级缓存，可以减少程序与数据库的交互，从而提高数据库访问性能。  
b)	SessionFactory级别的二级缓存是全局性的，所有的Session可以共享这个二级缓存。不过二级缓存默认是关闭的，需要显示开启并指定需要使用哪种二级缓存实现类（可以使用第三方提供的实现）。一旦开启了二级缓存并设置了需要使用二级缓存的实体类，SessionFactory就会缓存访问过的该实体类的每个对象，除非缓存的数据超出了指定的缓存空间。  
c)	一级缓存和二级缓存都是对整个实体进行缓存，不会缓存普通属性，如果希望对普通属性进行缓存，可以使用查询缓存。查询缓存是将HQL或SQL语句以及它们的查询结果作为键值对进行缓存，对于同样的查询可以直接从缓存中获取数据。查询缓存默认也是关闭的，需要显示开启。
169.	MyBatis中使用#和$书写占位符有什么区别？
a)	#将传入的数据都当成一个字符串，会对传入的数据自动加上引号；$将传入的数据直接显示生成在SQL中。注意：使用$占位符可能会导致SQL注射攻击，能用#的地方就不要使用$，写order by子句的时候应该用$而不是#。、
170.	什么是IoC和DI？DI是如何实现的？
a)	IoC叫控制反转，是Inversion of Control的缩写，DI（Dependency Injection）叫依赖注入，是对IoC更简单的诠释。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的"控制反转"就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。
b)	依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。
171.	Spring中自动装配的方式有哪些？
a)	no：不进行自动装配，手动设置Bean的依赖关系。  
b)	byName：根据Bean的名字进行自动装配。
c)	byType：根据Bean的类型进行自动装配。
d)	constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。
e)	autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。
172.	解释一下什么叫AOP（面向切面编程）？
a)	AOP（Aspect-Oriented Programming）指一种程序设计范型，该范型以一种称为切面（aspect）的语言构造为基础，切面是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点（crosscutting concern）。
173.	Spring中Bean的作用域有哪些？
a)	Singleton：Bean以单例的方式存在
b)	Prototype：表示每次从容器中调用Bean时，都会返回一个新的实例，prototype通常翻译为原型
c)	Request：每次HTTP请求都会创建一个新的Bean
d)	Session：同一个HttpSession共享同一个Bean，不同的HttpSession使用不同的Bean
e)	globalSession：同一个全局Session共享一个Bean
174.	Spring中如何使用注解来配置Bean？有哪些相关的注解？
a)	首先需要在Spring配置文件中增加配置：<context:component-scan base-package="org.example"/>
b)	用@Component、@Controller、@Service、@Repository注解来标注需要由Spring IoC容器进行对象托管的类。
i.	@Controller通常用于控制器
ii.	@Service通常用于业务逻辑类
iii.	@Repository通常用于DAO类
iv.	普通的类用@Component来标注。
175.	Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？
a)	Spring支持编程式事务管理和声明式事务管理。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理，因为编程式事务允许通过代码控制业务。
176.	Spring MVC的工作原理是怎样的？
a)	客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。
b)	 DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）。
c)	在这个地方Spring会通过HandlerAdapter对该处理器进行封装。
d)	HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用。
e)	Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView顾名思义，包含了数据模型以及相应的视图的信息。
f)	ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。
g)	当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。
h)	客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。
177.	阐述Spring框架中Bean的生命周期？
a)	Spring IoC容器找到关于Bean的定义并实例化该Bean。  
b)	pring IoC容器对Bean进行依赖注入。
c)	如果Bean实现了BeanNameAware接口，则将该Bean的id传给setBeanName方法。
d)	如果Bean实现了BeanFactoryAware接口，则将BeanFactory对象传给setBeanFactory方法。
e)	如果Bean实现了BeanPostProcessor接口，则调用其postProcessBeforeInitialization方法。
f)	如果Bean实现了InitializingBean接口，则调用其afterPropertySet方法。
g)	如果有和Bean关联的BeanPostProcessors对象，则这些对象的postProcessAfterInitialization方法被调用。
h)	当销毁Bean实例时，如果Bean实现了DisposableBean接口，则调用其destroy方法。
178.	启动一个程序，可以主界面点击图标进入，也可以从一个程序中跳转过去，二者有什么区别？
a)	通过主界面进入，就是设置默认启动的activity。在manifest.xml文件的activity标签中，写以下代码
<intent- filter>
<intent android:name=“android.intent.action.MAIN”>
<intent android:name=”android:intent.category.LAUNCHER”>
</intent-filter>
b)	从另一个组件跳转到目标activity，需要通过intent进行跳转。具体Intent intent=new Intent(this,activity.class),startActivity(intent)
179.	内存溢出和内存泄漏有什么区别？何时会产生内存泄漏？
a)	内存溢出：当程序运行时所需的内存大于程序允许的最高内存，这时会出现内存溢出
b)	内存泄漏：在一些比较消耗资源的操作中，如果操作中内存一直未被释放，就会出现内存泄漏。比如未关闭io,cursor。
180.	Android中常用布局
a)	常用的android有五种
b)	LinearLayout:：线性布局。类似与div，按照垂直或者水平方向进行组件的显示。可以通过指定orentation属性等于”vertical”或者”horizontal”
c)	absoluteLayout：绝对布局。通过指定坐标值来确定位置。但是不推荐使用
d)	relitiveLayout:：相对布局。组件的布局参考其他的组件的位置
e)	tableLayout：就是表格布局
f)	frameLayout：组件可以重叠与覆盖
181.	sim卡的EF 文件有何作用
a)	sim卡就是电话卡，sim卡内有自己的操作系统，用来与手机通讯的。Ef文件用来存储数据的。
182.	Activity的状态有几种？
a)	运行
b)	暂停
c)	停止
183.	activity的生命周期？
a)	onCreate：在创建activity实例的时候被调用，加载布局，初始化数据，渲染组件
b)	onStart：onStart在oncreate之后被调用，onStart方法之后调用onResume
c)	onResume：在与用户交互时调用该方法，在该方法运行之后，activity就处于运行状态
d)	onPause：当另一个activity即将显示在前台，会调用该方法，在这个方法内可以保存activity进行一些状态与数据的保存，该方法之后，activity就处于暂停状态
e)	onStop：当另一个activity替代当前activity显示在前台的时候，会调用onstop方法，这时activity就处于停止状态。
f)	onDestory：当结束activity或者因为内存已满关闭当前activity的时候，会调用onDestrory方法
g)	onRestart：当activity处于停止状态，需要调用onRestart方法，onRestart的后继方法是onStart方法
184.	横竖屏切换时候activity的生命周期
a)	当没有设置onConfigureChanges属性，切换的时候，会重新执行activity的生命周期，横屏的时候会执行1次，竖屏的时候会执行两次
b)	onConfigureChange=“orientation”时，横竖屏各会执行一次
c)	onConfigureChange=” orientation|keyboardHidden”时，横竖屏切换时不会重新执行。
185.	在android中mvc的具体体现
186.	让Activity变成一个窗口
a)	设置activity的style属性=”@android:style/Theme.Dialog”
187.	android:gravity与android:layout_gravity的区别
a)	gravity：表示组件内元素的对齐方式
b)	layout_gravity：相对于父类容器，该视图组件的对齐方式
188.	如何退出Activity
a)	结束当前activity
i.	Finish()
ii.	killProgress()
iii.	System.exit(0)
b)	关闭应用程序时，结束所有的activity
i.	可以创建一个List集合，每新创建一个activity，将该activity的实例放进list中，程序结束时，从集合中取出循环取出activity实例，调用finish()方法结束
189.	如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？
a)	在onPuase方法中调用onSavedInstanceState()
190.	activity的启动模式
a)	standard：标准的启动模式，每次创建一个activity实例
b)	singleTop：如果要创建activity在栈顶中存在实例，就直接使用，如果没有创建新的。
c)	singleTask：如果在栈中存在该activity的实例，就直接使用，并把该实例之前的其他activity实例删除.
d)	SingleInstance：如果在栈中存在该activity实例，直接使用。如果不存在，创建一个新的栈，并将该activity放入栈中。
191.	Android中的长度单位详解
a)	Px：像素
b)	Sp与dp也是长度单位，但是与屏幕的单位密度无关。
192.	Android中四大核心组件是什么？
a)	Activity：与用户交互的一个显示窗口
b)	Service：运行后台，不会显示在前台的组件
c)	broadcastReciever：广播接收者
d)	contentProvider：内容提供者
193.	activity，service，intent之间的关系
a)	这三个都是android应用频率非常的组件。Activity与service是四大核心组件。Activity用来加载布局，显示窗口界面，service运行后台，没有界面显示，intent是activity与service的通信使者。
194.	Activity1跳转到activity2，必须执行的方法有哪几个？
a)	当在activity1中激活activity2时，会指定activity1的onPause方法，接下来执行activity2的oncreate,onStart，onResume方法，当activity2替换activity1显示前台，这时候会执行activity1的onStop方法
195.	文件存储的方法有几种？
a)	sharedPreferences：共享参数
b)	文件存储：内部存储与外部存储
c)	Sqlite：数据库存储
d)	contentProvider：内容提供者
196.	activity之间传递参数，除了intent，广播接收器，contentProvider之外，还有那些方法？
a)	Fie：文件存储，推荐使用sharedPreferecnces
b)	静态变量。
197.	Adapter是什么？你所接触过的adapter有那些？
a)	是适配器，用来为列表提供数据适配的。经常使用的adapter有baseadapter，arrayAdapter，SimpleAdapter,cursorAdapter,SpinnerAdapter等
198.	Fragment与activity如何传值和交互？
a)	Fragment对象有一个getActivity的方法，通过该方法与activity交互
b)	使用framentmentManager.findFragmentByXX可以获取fragment对象，在activity中直接操作fragment对象
199.	如果Listview中的数据源发生改变，如何更新listview中的数据
a)	使用adapter的notifyDataSetChanged方法
200.	广播接受者的生命周期？
a)	广播接收者的生命周期非常短。当执行onRecieve方法之后，广播就会销毁
b)	在广播接受者不能进行耗时较长的操作
c)	在广播接收者不要创建子线程。广播接收者完成操作后，所在进程会变成空进程，很容易被系统回收
201.	广播都有哪几种？
a)	普通广播
i.	异步的广播，普通广播无法传递，普通无法中止广播的传播
b)	有序广播
i.	有多个广播，广播直接按照优先级的高低进行传播，广播在传播过程中，可以附加数据，可以接受数据。任何一个广播都有权利中止广播的传播。
ii.	sendOrderedBroadcast(Intent intent,String receiverPermission, BroadcastReceiver resultReceiver,Handler scheduler, int initialCode, String initialData,Bundle initialExtras)：resultReceiver表示的最后执行的广播，如果按照正常顺序，广播没有终端，resultReceiver这个广播会执行两次。比resultReceiver优先级高的广播如果中止了广播，resultReceiver只会执行一次
c)	粘性广播
i.	Intent会跟随广播一直存在，粘性广播没有普通广播10秒的限制。
202.	ContentProvider与sqlite有什么不一样的？
a)	ContentProvider会对外隐藏内部实现，只需要关注访问contentProvider的uri即可，contentProvider应用在应用间共享。
b)	Sqlite操作本应用程序的数据库。
c)	ContentProiver可以对本地文件进行增删改查操作
203.	如何保存activity的状态？
a)	默认情况下activity的状态系统会自动保存，有些时候需要我们手动调用保存。
b)	当activity处于onPause，onStop之后，activity处于未活动状态，但是activity对象却仍然存在。当内存不足，onPause，onStop之后的activity可能会被系统摧毁。
c)	当通过返回退出activity时，activity状态并不会保存。
d)	保存activity状态需要重写onSavedInstanceState()方法，在执行onPause,onStop之前调用onSavedInstanceState方法，onSavedInstanceState需要一个Bundle类型的参数，我们可以将数据保存到bundle中，通过实参传递给onSavedInstanceState方法。
e)	Activity被销毁后，重新启动时，在onCreate方法中，接受保存的bundle参数，并将之前的数据取出。
204.	Android中activity，context，application有什么不同。
a)	Content与application都继承与contextWrapper，contextWrapper继承于Context类。
b)	Context：表示当前上下文对象，保存的是上下文中的参数和变量，它可以让更加方便访问到一些资源。
c)	Context通常与activity的生命周期是一样的，application表示整个应用程序的对象。
d)	对于一些生命周期较长的，不要使用context，可以使用application。
e)	在activity中，尽量使用静态内部类，不要使用内部类。内部里作为外部类的成员存在，不是独立于activity，如果内存中还有内存继续引用到context，activity如果被销毁，context还不会结束。
205.	Service 是否在 main thread 中执行, service 里面是否能执行耗时的操作?
a)	默认情况service在main thread中执行，当service在主线程中运行，那在service中不要进行一些比较耗时的操作，比如说网络连接，文件拷贝等。
206.	Service 和 Activity 在同一个线程吗
a)	默认情况下service与activity在同一个线程，都在main Thread，或者ui线程中。
b)	如果在清单文件中指定service的process属性，那么service就在另一个进程中运行。
207.	Service 里面可以弹吐司么
a)	可以。
208.	在 service 的生命周期方法 onstartConmand()可不可以执行网络操作？如何在 service 中执行网络操作？
a)	可以的，就在onstartConmand方法内执行。
209.	Service的生命周期？
a)	在service的生命周期中有6个方法，onCreate()，onStartCommond()，stopService()，onBind()，onUnbind()，onDestory
b)	非绑定式服务
i.	生命周期：onCreate()，onStartCommond()， stopSeervice()，ondestory，
ii.	当退出activity没有调用stopService方法，service会继续运行在后台。
iii.	通过start启动服务之后，在前端无法结束服务，结束服务必须要调用StopService或者stopSelf方法
iv.	当服务结束之后，自动会调用onDestory方法
c)	绑定式服务
i.	生命周期：onCreate()，onBind，onUnBind，onDestory
ii.	通过onBind启动的服务，可以绑定多个视图组件，当所有的视图组件与service解绑后，service的生命才会结束。
d)	混合服务
i.	不管通过start或者onBind启动多少次服务，服务的实例只有一个，也就是说onCreate方法只执行一次
ii.	当调用startService之后，即使所有视图组件与Service解绑，但是服务仍然不会结束.
210.	说说 ContentProvider、ContentResolver、ContentObserver 之间的关系
a)	ContentProvider：内容提供者，对外提供数据的操作，contentProvider.notifyChanged(uir)：可以更新数据
b)	contentResolver：内容解析者，解析ContentProvider返回的数据
c)	ContentObServer:内容监听者，监听数据的改变，contentResolver.registerContentObServer()
211.	请介绍下 ContentProvider 是如何实现数据共享的
a)	ContentProvider是一个对外提供数据的接口，首先需要实现ContentProvider这个接口，然后重写query，insert，getType，delete，update方法，最后在清单文件定义contentProvider的访问uri
212.	Intent 传递数据时，可以传递哪些类型数据？
a)	基本数据类型以及对应的数组类型
b)	可以传递bundle类型，但是bundle类型的数据需要实现Serializable或者parcelable接口
213.	Serializable 和 Parcelable 的区别？
a)	如果存储在内存中，推荐使用parcelable，使用serialiable在序列化的时候会产生大量的临时变量，会引起频繁的GC 
b)	如果存储在硬盘上，推荐使用Serializable，虽然serializable效率较低
c)	Serializable的实现：只需要实现Serializable接口，就会自动生成一个序列化id
d)	Parcelable的实现：需要实现Parcelable接口，还需要Parcelable.CREATER变量
214.	请描述一下 Intent 和 IntentFilter
a)	Intent是组件的通讯使者，可以在组件间传递消息和数据。
b)	IntentFilter是intent的筛选器，可以对intent的action，data，catgory，uri这些属性进行筛选，确定符合的目标组件。
215.	BroadcastReciever有几种注册方式？
a)	静态注册：在清单文件配置Reciever节点，只要当前的activity一直运行，BroadcastReciever就可以接受来自系统和app的广播
b)	动态注册：使用代码进行注册，如果activity或者service被销毁的话，广播也就无效了
216.	什么是IntentService？有何优点？
a)	IntentService 是 Service 的子类，比普通的 Service 增加了额外的功能。先看 Service 本身存在两个问题：
i.	Service 不会专门启动一条单独的进程，Service 与它所在应用位于同一个进程中；
ii.	Service 也不是专门一条新线程，因此不应该在 Service 中直接处理耗时的任务；
b)	特征
i.	会创建独立的 worker 线程来处理所有的 Intent 请求；
ii.	会创建独立的 worker 线程来处理 onHandleIntent()方法实现的代码，无需处理多线程问题；
iii.	所有请求处理完成后，IntentService 会自动停止，无需调用 stopSelf()方法停止 Service；
iv.	为 Service 的 onBind()提供默认实现，返回 null；
v.	为 Service 的 onStartCommand 提供默认实现，将请求 Intent 添加到队列中
c)	使用
i.	让service类继承IntentService，重写onStartCommand和onHandleIntent实现
217.	Android 引入广播机制的用意
a)	从 MVC 的角度考虑(应用程序内) 其实回答这个问题的时候还可以这样问，android 为什么要有那 4 大组件，现在的移动开发模型基本上也是照搬的 web 那一套 MVC 架构，只不过稍微做了修改。android 的四大组件本质上就是为了实现移动或者说嵌入式设备上的 MVC 架构，它们之间有时候是一种相互依存的关系，有时候又是一种补充关系，引入广播机制可以方便几大组件的信息和数据交互。
b)	程序间互通消息(例如在自己的应用程序内监听系统来电)
c)	效率上(参考 UDP 的广播协议在局域网的方便性)
d)	设计模式上(反转控制的一种应用，类似监听者模式)
218.	ListView 如何提高其效率？
a)	当 convertView 为空时，用 setTag()方法为每个 View 绑定一个存放控件的 ViewHolder 对象。当convertView 不为空， 重复利用已经创建的 view 的时候， 使用 getTag()方法获取绑定的 ViewHolder对象，这样就避免了 findViewById 对控件的层层查询，而是快速定位到控件。 复用 ConvertView，使用历史的 view，提升效率 200%
b)	自定义静态类 ViewHolder，减少 findViewById 的次数。提升效率 50%
c)	异步加载数据，分页加载数据。
d)	使用 WeakRefrence 引用 ImageView 对象
219.	ListView 如何实现分页加载
a)	设置 ListView 的滚动监听器：setOnScrollListener(new OnScrollListener{….})在监听器中有两个方法： 滚动状态发生变化的方法(onScrollStateChanged)和 listView 被滚动时调用的方法(onScroll)
b)	在滚动状态发生改变的方法中，有三种状态：手指按下移动的状态： SCROLL_STATE_TOUCH_SCROLL:触摸滑动，惯性滚动（滑翔（flgin）状态）： SCROLL_STATE_FLING: 滑翔，静止状态： SCROLL_STATE_IDLE: // 静止，对不同的状态进行处理：
c)	分批加载数据，只关心静止状态：关心最后一个可见的条目，如果最后一个可见条目就是数据适配器（集合）里的最后一个，此时可加载更多的数据。在每次加载的时候，计算出滚动的数量，当滚动的数量大于等于总数量的时候，可以提示用户无更多数据了。
220.	ListView 可以显示多种类型的条目吗
a)	这个当然可以的，ListView 显示的每个条目都是通过 baseAdapter 的 getView(int position,View convertView, ViewGroup parent)来展示的，理论上我们完全可以让每个条目都是不同类型的view。
b)	比如：从服务器拿回一个标识为 id=1,那么当 id=1 的时候，我们就加载类型一的条目，当 id=2的时候，加载类型二的条目。常见布局在资讯类客户端中可以经常看到。
c)	除此之外 adapter 还提供了 getViewTypeCount（）和 getItemViewType(int position)两个方法。在 getView 方法中我们可以根据不同的 viewtype 加载不同的布局文件。
221.	ListView 如何定位到指定位置
a)	可以通过 ListView 提供的 lv.setSelection(listView.getPosition())方法。
222.	如何在 ScrollView 中如何嵌入 ListView
a)	通常情况下我们不会在 ScrollView 中嵌套 ListView。
b)	在 ScrollView 添加一个 ListView 会导致 listview 控件显示不全，通常只会显示一条，这是因为两个控件的滚动事件冲突导致。所以需要通过 listview 中的 item 数量去计算 listview 的显示高度，从而使其完整展示。 
c)	现阶段最好的处理的方式是： 自定义 ListView，重载 onMeasure()方法，设置全部显示。 
223.	ListView 中如何优化图片
a)	处理图片的方式：
i.	如果 ListView 中自定义的 Item 中有涉及到大量图片的，一定要对图片进行细心的处理，因为图片占的内存是 ListView 项中最头疼的，处理图片的方法大致有以下几种：
1.	不要直接拿路径就去循环 BitmapFactory.decodeFile;使用 Options 保存图片大小、不要加载图片到内存去。
2.	对图片一定要经过边界压缩尤其是比较大的图片，如果你的图片是后台服务器处理好的那就不需要了
3.	在 ListView 中取图片时也不要直接拿个路径去取图片，而是以 WeakReference（使用
ii.	WeakReference 代替强引用。比如可以使用 WeakReference mContextRef）、SoftReference、WeakHashMap 等的来存储图片信息。
iii.	在 getView 中做图片转换时，产生的中间变量一定及时释放
b)	异步加载图片基本思想：
i.	先从内存缓存中获取图片显示（内存缓冲）
ii.	获取不到的话从 SD 卡里获取（SD 卡缓冲）
iii.	都获取不到的话从网络下载图片并保存到 SD 卡同时加入内存并显示（视情况看是否要显示）
c)	原理：
i.	优化一：先从内存中加载，没有则开启线程从 SD 卡或网络中获取，这里注意从 SD 卡获取图片是放在子线程里执行的，否则快速滑屏的话会不够流畅。
ii.	优化二：于此同时，在 adapter 里有个 busy 变量，表示 listview 是否处于滑动状态，如果是滑动状态则仅从内存中获取图片，没有的话无需再开启线程去外存或网络获取图片。
iii.	优化三：ImageLoader 里的线程使用了线程池，从而避免了过多线程频繁创建和销毁，如果每次总是 new 一个线程去执行这是非常不可取的，好一点的用的 AsyncTask 类，其实内部也是用到了线程池。在从网络获取图片时，先是将其保存到 sd 卡，然后再加载到内存，这么做的好处是在加载到内存时可以做个压缩处理，以减少图片所占内存。
224.	ListView 中图片错位的问题是如何产生的
a)	图片错位问题的本质源于我们的 listview 使用了缓存 convertView， 假设一种场景， 一个 listview一屏显示九个 item，那么在拉出第十个 item 的时候，事实上该 item 是重复使用了第一个 item，也就是说在第一个 item 从网络中下载图片并最终要显示的时候，其实该 item 已经不在当前显示区域内了，此时显示的后果将可能在第十个 item 上输出图像，这就导致了图片错位的问题。所以解决办法就是可见则显示，不可见则不显示。
225.	描述一下 Fragment 的生命周期 
226.	Fragment 的 replace 和 add 方法的区别
a)	Fragment 本身并没有 replace 和 add 方法，FragmentManager才有replace和add方法。我们经常使用的一个架构就是通过RadioGroup切换Fragment，每个 Fragment 就是一个功能模块。
b)	Fragment 的容器一个 FrameLayout，add 的时候是把所有的 Fragment 一层一层的叠加到了。FrameLayout 上了，而 replace 的话首先将该容器中的其他 Fragment 去除掉然后将当前Fragment添加到容器中。
c)	一个 Fragment 容器中只能添加一个 Fragment 种类，如果多次添加则会报异常，导致程序终止，而 replace 则无所谓，随便切换。因为通过 add 的方法添加的 Fragment，每个 Fragment 只能添加一次，因此如果要想达到切换效果需要通过 Fragment 的的 hide 和 show 方法结合者使用。将要显示的 show 出来，将其他 hide起来。这个过程 Fragment 的生命周期没有变化。
d)	通过 replace 切换 Fragment，每次都会执行上一个 Fragment 的 onDestroyView，新 Fragment的 onCreateView、onStart、onResume 方法。基于以上不同的特点我们在使用的使用一定要结合着生命周期操作我们的视图和数据。
227.	Fragment 如何实现类似 Activity 栈的压栈和出栈效果的？
a)	Fragment 的事物管理器内部维持了一个双向链表结构，该结构可以记录我们每次 add 的Fragment 和 replace 的 Fragment，然后当我们点击 back 按钮的时候会自动帮我们实现退栈操作。
228.	Fragment 在你们项目中的使用
a)	Fragment 是 android3.0 以后引入的的概念，做局部内容更新更方便，原来为了到达这一点要把多个布局放到一个 activity 里面，现在可以用多 Fragment 来代替，只有在需要的时候才加载Fragment，提高性能。
b)	Fragment 的好处：
i.	Fragment 可以使你能够将 activity 分离成多个可重用的组件，每个都有它自己的生命周期和UI。
ii.	Fragment 可以轻松得创建动态灵活的 UI 设计，可以适应于不同的屏幕尺寸。从手机到平板电脑。
iii.	Fragment 是一个独立的模块,紧紧地与 activity 绑定在一起。可以运行中动态地移除、加入、交换等。
iv.	Fragment 提供一个新的方式让你在不同的安卓设备上统一你的 UI。
v.	Fragment 解决 Activity 间的切换不流畅，轻量切换。
vi.	Fragment 替代 TabActivity 做导航，性能更好。
vii.	Fragment 在 4.2.版本中新增嵌套 fragment 使用方法，能够生成更好的界面效果。
229.	如何切换 fragement,不重新实例化
a)	翻看了 Android 官方 Doc，和一些组件的源代码，发现 replace()这个方法只是在上一个 Fragment不再需要时采用的简便方法.
b)	正确的切换方式是 add()，切换时 hide()，add()另一个 Fragment；再次切换时，只需 hide()当前，show()另一个。
c)	这样就能做到多个 Fragment 切换不重新实例化： 
230.	什么情况下会导致内存泄露
a)	Android 的虚拟机是能利用的内存空间是有限的。如果我们的内存占用超过了一定的水平就会出现OutOfMemory 的错误。
b)	内存溢出的几点原因：
i.	1. 资源释放问题：程序代码的问题，长期保持某些资源，如 Context、Cursor、IO 流的引用，资源得不到释放造成内存泄露。
ii.	对象内存过大问题：保存了多个耗用内存过大的对象（如 Bitmap、XML 文件），造成内存超出限制。
iii.	 static 关键字的使用问题：static 是 Java 中的一个关键字，当用它来修饰成员变量时，那么该变量就属于该类，而不是该类的实例。所以用 static 修饰的变量，它的生命周期是很长的，如果用它来引用一些资源耗费过多的实例（Context 的情况最多），这时就要谨慎对待了。针对 static 的解决方案
1.	应该尽量避免 static 成员变量引用资源耗费过多的实例，比如 Context。
2.	Context 尽量使用 ApplicationContext，因为 Application 的 Context 的生命周期比较长，引用它不会出现内存泄露的问题。
3.	使 用 WeakReference 代 替 强 引 用 。 比 如 可 以 使 用 WeakReference<Context> mContextRef;
iv.	 线程导致内存溢出
1.	线程产生内存泄露的主要原因在于线程生命周期的不可控。
2.	有些人喜欢用 Android 提供的 AsyncTask，但事实上 AsyncTask 的问题更加严重，Thread 只有在 run 函数不结束时才出现这种内存泄露问题，然而 AsyncTask 内部的实现机制是运用了ThreadPoolExcutor,该类产生的 Thread 对象的生命周期是不确定的，是应用程序无法控制的，因此如果 AsyncTask 作为 Activity 的内部类，就更容易出现内存泄露的问题。
3.	针对这种线程导致的内存泄露问题的解决方案：
a)	将线程的内部类，改为静态内部类（因为非静态内部类拥有外部类对象的强引用，而静态类则不拥有）。
b)	在线程内部采用弱引用保存 Context 引用。
231.	如何避免 OOM 异常
a)	OOM 内存溢出，想要避免 OOM 异常首先我们要知道什么情况下会导致 OOM 异常。
i.	图片过大导致 OOM
1.	Android 中用 bitmap 时很容易内存溢出，比如报如下错误：Java.lang.OutOfMemoryError :bitmap size exceeds VM budget。
2.	解决方法：
a)	等比例缩小图片 
b)	对图片采用软引用，及时地进行 recyle()操作 
c)	使用加载图片框架处理图片，如专业处理加载图片的 ImageLoader 图片加载框架。还有XUtils 的 BitMapUtils 来做处理。
b)	界面切换导致 OOM
1.	一般情况下，开发中都会禁止横屏的。因为如果是来回切换话，activity 的生命周期会重新销毁然后创建。有时候我们会发现这样的问题，横竖屏切换 N 次后 OOM 了。这种问题没有固定的解决方法，但是我们可以从以下几个方面下手分析。
i.	看看页面布局当中有没有大的图片，比如背景图之类的。去除 xml 中相关设置，改在程序中设置背景图（放在 onCreate()方法中）： 在 Activity destory 时注意，drawable.setCallback(null); 防止 Activity 得不到及时的释放。
ii.	跟上面方法相似，直接把 xml 配置文件加载成 view 再放到一个容器里，然后直接调用this.setContentView(View view);方法，避免 xml 的重复加载。
iii.	在页面切换时尽可能少地重复使用一些代码。比如：重复调用数据库，反复使用某些对象等等......
c)	查询数据库没有关闭游标
i.	程序中经常会进行查询数据库的操作，但是经常会有使用完毕 Cursor 后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会出现内存问题，这样就会给以后的测试和问题排查带来困难和风险。
d)	构造 Adapter 时，没有使用缓存的 convertView
i.	在使用 ListView 的时候通常会使用 Adapter，那么我们应该尽可能的使用 ConvertView。为什么要使用 convertView?当 convertView 为空时，用 setTag()方法为每个 View 绑定一个存放控件的 ViewHolder 对象。当 convertView 不为空，重复利用已经创建的 view 的时候，使用 getTag()方法获取绑定的ViewHolder 对象，这样就避免了 findViewById 对控件的层层查询，而是快速定位到控件。
e)	Bitmap 对象不再使用时调用 recycle()释放内存
i.	有时我们会手工的操作 Bitmap 对象，如果一个 Bitmap 对象比较占内存，当它不再被使用的时候，可以调用 Bitmap.recycle()方法回收此对象的像素所占用的内存，但这不是必须的，视情况而定。
f)	其他
i.	Android 应用程序中最典型的需要注意释放资源的情况是在 Activity 的生命周期中，在onPause()、onStop()、 onDestroy()方法中需要适当的释放资源的情况。使用广播没有注销也会产生 OOM。
232.	如何对 Android 应用进行性能分析
a)	如果不考虑使用其他第三方性能分析工具的话，我们可以直接使用 ddms 中的工具，其实 ddms 工具已经非常的强大了。ddms 中有 traceview、heap、allocation tracker 等工具都可以帮助我们分析应用的方法执行时间效率和内存使用情况。
b)	TraceView 
i.	Traceview 是 Android 平台特有的数据采集和分析工具，它主要用于分析 Android 中应用程序的 hotspot（瓶颈）。Traceview 本身只是一个数据分析工具，而数据的采集则需要使用 AndroidSDK 中的 Debug 类或者利用 DDMS 工具。
c)	heap
i.	heap 工具可以帮助我们检查代码中是否存在会造成内存泄漏的地方。
d)	allocation tracker
i.	allocation tracker 是内存分配跟踪工具
233.	Android 中如何捕获未捕获的异常
a)	UncaughtExceptionHandler
i.	自 定 义 一 个 Application ， 比 如 叫 MyApplication 继 承 Application 实 现UncaughtExceptionHandler。
ii.	覆写 UncaughtExceptionHandler 的 onCreate 和 uncaughtException 方法。 注意：上面的代码只是简单的将异常打印出来。在 onCreate 方法中我们给 Thread 类设置默认异常处理 handler，如果这句代码不执行则一切都是白搭。在 uncaughtException 方法中我们必须新开辟个线程进行我们异常的收集工作，然后将系统给杀死。
iii.	在 AndroidManifest 中配置该 Application：<application android:name="com.example.uncatchexception.MyApplication"
b)	Bug 收集工具 Crashlytics
i.	Crashlytics 是专门为移动应用开发者提供的保存和分析应用崩溃的工具。国内主要使用的是友盟做数据统计。
ii.	Crashlytics 的好处：
1.	Crashlytics 不会漏掉任何应用崩溃信息。
2.	Crashlytics 可以象 Bug 管理工具那样，管理这些崩溃日志。
3.	Crashlytics 可以每天和每周将崩溃信息汇总发到你的邮箱，所有信息一目了然。
234.	如何将SQLite数据库(dictionary.db文件)与apk文件一起发布
a)	把这个文件放在/res/raw目录下即可。res\raw目录中的文件不会被压缩，这样可以直接提取该目录中的文件，会生成资源id。
235.	什么是 IntentService？有何优点？
a)	IntentService 是 Service 的子类，比普通的 Service 增加了额外的功能。先看 Service 本身存在两个问题：
i.	Service 不会专门启动一条单独的进程，Service 与它所在应用位于同一个进程中；
ii.	Service 也不是专门一条新线程，因此不应该在 Service 中直接处理耗时的任务；
b)	IntentService 特征
i.	会创建独立的 worker 线程来处理所有的 Intent 请求；
ii.	会创建独立的 worker 线程来处理 onHandleIntent()方法实现的代码，无需处理多线程问题；
iii.	所有请求处理完成后，IntentService 会自动停止，无需调用 stopSelf()方法停止 Service；
iv.	为 Service 的 onBind()提供默认实现，返回 null；
v.	为 Service 的 onStartCommand 提供默认实现，将请求 Intent 添加到队列中；
236.	谈谈对Android NDK的理解
a)	NDK是一系列工具的集合.NDK提供了一系列的工具,帮助开发者快速开发C或C++的动态库,并能自动将so和java应用一起打包成apk.这些工具对开发者的帮助是巨大的.NDK集成了交叉编译器,并提供了相应的mk文件隔离CPU,平台,ABI等差异,开发人员只需要简单修改 mk文件(指出"哪些文件需要编译","编译特性要求"等),就可以创建出so. 
b)	NDK可以自动地将so和Java应用一起打包,极大地减轻了开发人员的打包工作.NDK提供了一份稳定,功能有限的API头文件声明. 
c)	Google明确声明该API是稳定的,在后续所有版本中都稳定支持当前发布的API.从该版本的NDK中看出,这些 API支持的功能非常有限,包含有:C标准库(libc),标准数学库(libm ),压缩库(libz),Log库(liblog).
237.	AsyncTask使用在哪些场景？它的缺陷是什么？如何解决？
a)	AsyncTask 运用的场景就是我们需要进行一些耗时的操作，耗时操作完成后更新主线程，或者在操作过程中对主线程的UI进行更新。 
b)	缺陷：AsyncTask中维护着一个长度为128的线程池，同时可以执行5个工作线程，还有一个缓冲队列，当线程池中已有128个线程，缓冲队列已满时，如果 此时向线程提交任务，将会抛出RejectedExecutionException。 
c)	解决：由一个控制线程来处理AsyncTask的调用判断线程池是否满了，如果满了则线程睡眠否则请求AsyncTask继续处理。
238.	ANR 是什么？怎样避免和解决
a)	在 Android 上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框，这个对话框称作应用程序无响应（ANR：Application Not Responding）对话框。用户可以选择让程序继续运行，但是，他们在使用你的应用程序时，并不希望每次都要处理这个对话框。因此，在程序里对响应性能的设计很重要，这样，系统不会显示 ANR 给用户。Activity是 5 秒， broadcast10 秒。对于耗时的操作 worker thread 里面完成, handler message…AsynTask , intentservice等
b)	ANR:Application Not Responding，即应用无响应。ANR 一般有三种类型：
i.	KeyDispatchTimeout(5 seconds) --主要类型
1.	按键或触摸事件在特定时间内无响应
ii.	BroadcastTimeout(10 seconds)
1.	BroadcastReceiver 在特定时间内无法处理完成
iii.	ServiceTimeout(20 seconds) --小概率类型
1.	Service 在特定的时间内无法处理完成
2.	超时的原因一般有两种：
a)	当前的事件没有机会得到处理（UI 线程正在处理前一个事件没有及时完成或者 looper 被某种原因阻塞住）
b)	当前的事件正在处理，但没有及时完成UI 线程尽量只做跟 UI 相关的工作，耗时的工作（数据库操作，I/O，连接网络或者其他可能阻碍 UI线程的操作）放入单独的线程处理，尽量用 Handler 来处理 UI thread 和 thread 之间的交互。UI 线程主要包括如下：
i.	Activity:onCreate(), onResume(), onDestroy(), onKeyDown(), onClick()
ii.	AsyncTask: onPreExecute(), onProgressUpdate(), onPostExecute(), onCancel()
iii.	Mainthread handler: handleMessage(), post(runnable r)
c)	查找 ANR 的方式： 1. 导出/data/data/anr/traces.txt，找出函数和调用过程，分析代码 2. 通过性能 LOG查找
239.	Android 线程间通信有哪几种方式（重要）
a)	共享内存（变量）；
b)	文件，数据库；
c)	Handler；
d)	Java 里的 wait()，notify()，notifyAll()
240.	android 应用对内存是如何限制的?我们应该如何合理使用内存？
a)	如何限制的？
i.	Android 应用的开发语言为 Java，每个应用最大可使用的堆内存受到 Android 系统的限制
ii.	Android 每一个应用的堆内存大小有限，通常的情况为 16M-48M
iii.	通过 ActivityManager 的 getMemoryClass()来查询可用堆内存限制
1.	3.0(HoneyComb)以上的版本可以通过 largeHeap=“true”来申请更多的堆内存
2.	NexusS(4.2.1):normal 192, largeHeap 512
3.	如果试图申请的内存大于当前余下的堆内存就会引发 OutOfMemoryError()
iv.	应用程序由于各方面的限制，需要注意减少内存占用，避免出现内存泄漏。
b)	如何合理使用内存？
i.	注意资源回收，像数据库，输入输出流，定位操作这样的对象，要在使用完及时关闭流。
ii.	少使用静态变量，因为系统将静态变量的优先级设定的很高，会最后回收。所以可能因为静态变量导致该回收的没有回收。而回收了不该回收的内存。
iii.	注意大图片的缩放，如果载入的图片很大，要先经过自己程序的处理，降低分辨率等。最好设置多种分辨率格式的图片，以减少内存消耗。
iv.	动态注册监听，把一些只有显示的时候才使用到的监听放进程序内部，而不是放在 manifesat中去。
v.	减少使用动画，或者适当减少动画的帧数。
vi.	注意自己的程序逻辑，在该关闭自己程序的控件的时候，主动关闭，不要交给系统去决定。（这个要自己把握好， 也不是说都自己搞定， 只有那些自己确定需要关闭的对象， 自己将其关闭。 ）
241.	请解释下 Android 程序运行时权限与文件系统权限的区别？
a)	apk 程序是运行在虚拟机上的,对应的是 Android 独特的权限机制，只有体现到文件系统上时才
b)	使用 linux 的权限设置。
i.	linux 文件系统上的权限
1.	-rwxr-x--x system system 4156 2010-04-30 16:13 test.apk
2.	代表的是相应的用户/用户组及其他人对此文件的访问权限，与此文件运行起来具有的权限完全不相关。比如上面的例子只能说明 system 用户拥有对此文件的读写执行权限；system 组的用户对此文件拥有读、执行权限；其他人对此文件只具有执行权限。而 test.apk 运行起来后可以干哪些事情，跟这个就不相关了。千万不要看 apk 文件系统上属于 system/system 用户及用户组，或者root/root 用户及用户组，就认为 apk 具有 system 或 root 权限
c)	Android 的权限规则
i.	Android 中的 apk 必须签名
ii.	基于 UserID 的进程级别的安全机制
iii.	默认 apk 生成的数据对外是不可见的
iv.	AndroidManifest.xml 中的显式权限声明
242.	Framework 工作方式及原理，Activity 是如何生成一个 view 的，机制是什么？
a)	所有的框架都是基于反射 和 配置文件（manifest）的。
b)	普通的情况:
i.	Activity 创建一个 view 是通过 ondraw 画出来的, 画这个 view 之前呢,还会调用 onmeasure方法来计算显示的大小.
c)	特殊情况：
i.	Surfaceview 是直接操作硬件的，因为 或者视频播放对帧数有要求，onDraw 效率太低，不够使，Surfaceview 直接把数据写到显存。
243.	什么是 AIDL？如何使用？
a)	aidl 是 Android interface definition Language 的英文缩写，意思 Android 接口定义语言。
b)	使用 aidl 可以帮助我们发布以及调用远程服务，实现跨进程通信。
i.	将服务的 aidl 放到对应的 src 目录，工程的 gen 目录会生成相应的接口类
ii.	我们通过 bindService（Intent，ServiceConnect，int）方法绑定远程服务，在 bindService中 有 一 个 ServiceConnec 接 口 ， 我 们 需 要 覆 写 该 类 的onServiceConnected(ComponentName,IBinder)方法，这个方法的第二个参数 IBinder 对象其实就是已经在 aidl 中定义的接口，因此我们可以将 IBinder 对象强制转换为 aidl 中的接口类。我们通过 IBinder 获取到的对象（也就是 aidl 文件生成的接口）其实是系统产生的代理对象，该代理对象既可以跟我们的进程通信， 又可以跟远程进程通信， 作为一个中间的角色实现了进程间通信。
244.	AIDL 的全称是什么?如何工作?能处理哪些类型的数据？
a)	AIDL 全称 Android Interface Definition Language（AndRoid 接口描述语言） 是一种接口描述语言; 编译器可以通过 aidl 文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程跨界对象访问的目的。需要完成两件事情：
1.	引入 AIDL 的相关类.; 
2.	调用 aidl 产生的 class
b)	理论上, 参数可以传递基本数据类型和 String, 还有就是 Bundle 的派生类, 不过在 Eclipse 中,目前的 ADT 不支持 Bundle 做为参数。
245.	Android 判断SD卡是否存在
a)	首先要在AndroidManifest.xml中增加SD卡访问权限
b)	 
246.	Android中任务栈的分配
a)	Task实际上是一个Activity栈，通常用户感受的一个Application就是一个Task。从这个定义来看，Task跟Service或者其他Components是没有任何联系的，它只是针对Activity而言的。
b)	Activity有不同的启动模式, 可以影响到task的分配
247.	SQLite支持事务吗? 添加删除如何提高性能?
a)	在sqlite插入数据的时候默认一条语句就是一个事务，有多少条数据就有多少次磁盘操作 比如5000条记录也就是要5000次读写磁盘操作。
b)	添加事务处理，把多条记录的插入或者删除作为一个事务
248.	view如何刷新？简述什么是双缓冲？
a)	android中实现view的刷新有两个方法，一个是invalidate()，另一个是postInvalidate()，其中前者是在UI线程自身中使用，而后者在非UI线程中使用。  
b)	出现屏幕闪烁是图形编程的一个常见问题。当进行复杂的绘制操作时会导致呈现的图像闪烁或具有其他不可接受的外观。双缓冲的使用解决这些问题。双缓冲使用内存缓冲区来解决由多重绘制操作造成的闪烁问题。当使用双缓冲时，首先在内存缓冲区里完成所有绘制操作，而不是在屏幕上直接进行绘图。当所有绘制操作完成后，把内存缓冲区完成的图像直接复制到屏幕。因为在屏幕上只执行一个图形操作，所以消除了由复杂绘制操作造成的图像闪烁问题。  在android中实现双缓冲,可以使用一个后台画布backcanvas,先把所有绘制操作都在这上面进行。等图画好了，然后在把backcanvas拷贝到 与屏幕关联的canvas上去,如下:  Bitmap bitmapBase = new Bitmap() Canvas backcanvas = new Canvas(bitmapBase) backcanvas.draw()...//画图 Canvas c = lockCanvas(null); c.drawbitmap(bitmapBase);//把已经画好的图像输出到屏幕上 unlock(c)....
249.	描述下Handler 机制
a)	Android 中主线程也叫 UI 线程，主要是用来创建、更新 UI 的，而其他耗时操作，比如网络访问，或者文件处理，多媒体处理等都需要在子线程中操作，之所以在子线程中操作是为了保证 UI 的流畅程度，手机显示的刷新频率是 60Hz，也就是一秒钟刷新 60 次，每16.67 毫秒刷新一次，为了不丢帧，那么主线程处理代码最好不要超过 16 毫秒。当子线程处理完数据后，为了防止 UI 处理逻辑的混乱，Android 只允许主线程修改 UI，那么这时候就需要 Handler来充当子线程和主线程之间的桥梁了。
b)	我们通常将 Handler 声明在 Activity 中，然后覆写 Handler 中的 handleMessage 方法,当子线程调用 handler.sendMessage()方法后 handleMessage 方法就会在主线程中执行。
c)	这里面除了 Handler、Message 外还有隐藏的 Looper 和 MessageQueue 对象。在主线程中 Android 默认已经调用了 Looper.preper()方法，调用该方法的目的是在 Looper 中创 建 MessageQueue 成 员 变 量 并 把 Looper 对 象 绑 定 到 当 前 线 程 中 。 当 调 用 Handler 的sendMessage（对象）方法的时候就将 Message 对象添加到了 Looper 创建的 MessageQueue队列中，同时给 Message 指定了 target 对象，其实这个 target 对象就是 Handler 对象。主线程默认执行了 Looper.looper （） 方法， 该方法从 Looper 的成员变量 MessageQueue 中取出 Message，然后调用 Message 的 target 对象的 handleMessage()方法。这样就完成了整个消息机制。
250.	请描述一下 Android 的事件分发机制
a)	Android 的事件分发机制主要是 Touch 事件分发，有两个主角:ViewGroup 和 View。Activity的 Touch 事件事实上是调用它内部的 ViewGroup 的 Touch 事件，可以直接当成 ViewGroup 处理。View 在 ViewGroup 内， ViewGroup 也可以在其他 ViewGroup 内， 这时候把内部的 ViewGroup当成 View 来分析。
b)	先分析 ViewGroup 的处理流程：首先得有个结构模型概念：ViewGroup 和 View 组成了一棵树形结构，最顶层为 Activity 的 ViewGroup，下面有若干的 ViewGroup 节点，每个节点之下又有若干的 ViewGroup 节点或者 View 节点，依次类推。如图： 
c)	当一个 Touch 事件(触摸事件为例)到达根节点，即 Acitivty 的 ViewGroup 时，它会依次下发，下发的过程是调用子 View(ViewGroup)的 dispatchTouchEvent 方法实现的。简单来说，就是ViewGroup 遍历它包含着的子 View，调用每个 View 的 dispatchTouchEvent 方法，而当子 View为 ViewGroup 时，又会通过调用 ViwGroup 的 dispatchTouchEvent 方法继续调用其内部的 View的 dispatchTouchEvent 方法。上述例子中的消息下发顺序是这样的：①-②-⑤-⑥-⑦-③-④。
d)	dispatchTouchEvent 方法只负责事件的分发，它拥有 boolean 类型的返回值，当返回为 true 时，顺序下发会中断。在上述例子中如果⑤的 dispatchTouchEvent 返回结果为 true，那么⑥-⑦-③-④将都接收不到本次 Touch 事件。
i.	Touch 事 件 分 发 中 只 有 两 个 主 角 :ViewGroup和View。ViewGroup包含onInterceptTouchEvent 、 dispatchTouchEvent 、 onTouchEvent 三 个 相 关 事 件 。 View 包 含dispatchTouchEvent、onTouchEvent 两个相关事件。其中 ViewGroup 又继承于 View。
ii.	ViewGroup 和 View 组成了一个树状结构，根节点为 Activity 内部包含的一个 ViwGroup。
iii.	触摸事件由 Action_Down、Action_Move、Aciton_UP 组成，其中一次完整的触摸事件中，Down 和 Up 都只有一个，Move 有若干个，可以为 0 个。
iv.	当 Acitivty 接收到 Touch 事件时，将遍历子 View 进行 Down 事件的分发。ViewGroup 的遍历可以看成是递归的。分发的目的是为了找到真正要处理本次完整触摸事件的 View，这个 View 会在 onTouchuEvent 结果返回 true。
v.	当某个子 View 返回 true 时， 会中止 Down 事件的分发， 同时在 ViewGroup 中记录该子 View。接下去的 Move 和 Up 事件将由该子 View 直接进行处理。 由于子 View 是保存在 ViewGroup 中的，多层 ViewGroup 的节点结构时，上级 ViewGroup 保存的会是真实处理事件的 View 所在的ViewGroup 对象:如 ViewGroup0-ViewGroup1-TextView 的结构中，TextView 返回了 true，它将被保存在 ViewGroup1 中，而 ViewGroup1 也会返回 true，被保存在 ViewGroup0 中。当 Move和 UP 事件来时，会先从 ViewGroup0 传递至 ViewGroup1，再由 ViewGroup1 传递至 TextView。
vi.	当 ViewGroup 中所有子 View 都不捕获 Down 事件时，将触发 ViewGroup 自身的 onTouch事件。触发的方式是调用 super.dispatchTouchEvent 函数，即父类 View 的 dispatchTouchEvent方法。在所有子 View 都不处理的情况下，触发 Acitivity 的 onTouchEvent 方法。
vii.	onInterceptTouchEvent 有两个作用：1.拦截 Down 事件的分发。2.中止 Up 和 Move 事件向目标 View 传递，使得目标 View 所在的 ViewGroup 捕获 Up 和 Move 事件。
251.	子线程发消息到主线程进行更新 UI，除了 handler 和 AsyncTask，还有什么？
a)	用 Activity 对象的 runOnUiThread 方法更新
i.	在子线程中通过 runOnUiThread()方法更新 UI：
 
ii.	如果在非上下文类中（Activity），可以通过传递上下文实现调用；
 
b)	用 View.post(Runnable r)方法更新 UI
 
252.	子线程中能不能 new handler？为什么？
a)	不能,如果在子线程中直接 new Handler()会抛出异常 java.lang.RuntimeException: Can'tcreate handler inside thread that has not called
b)	在没有调用 Looper.prepare()的时候不能创建 Handler,因为在创建 Handler 的源码中做了如下操作
c)	Handler 的构造方法中 
253.	Android 中的动画有哪几类，它们的特点和区别是什么
a)	Frame Animation(帧动画)主要用于播放一帧帧准备好的图片，类似GIF图片，优点是使用简单方便、缺点是需要事先准备好每一帧图片；
b)	Tween Animation(补间动画)仅需定义开始与结束的关键帧，而变化的中间帧由系统补上，优点是不用准备每一帧，缺点是只改变了对象绘制，而没有改变View本身属性。因此如果改变了按钮的位置，还是需要点击原来按钮所在位置才有效。
c)	Property Animation(属性动画)是3.0后推出的动画，优点是使用简单、降低实现的复杂度、直接更改对象的属性、几乎可适用于任何对象而仅非View类，主要包括ValueAnimator和ObjectAnimator
254.	如何修改 Activity 进入和退出动画
a)	可 以 通 过 两 种 方 式 ， 一 是 通 过 定 义 Activity 的 主 题 ， 二 是 通 过 覆 写 Activity 的overridePendingTransition 方法。
b)	通过设置主题样式在 styles.xml 中编辑如下代码：
i.	添加 themes.xml 文件： 
ii.	在 AndroidManifest.xml 中给指定的 Activity 指定 theme。 
c)	覆写 overridePendingTransition 方法
i.	overridePendingTransition(R.anim.fade, R.anim.hold);
255.	如何实现文件断点上传
a)	在 Android 中上传文件可以采用 HTTP 方式，也可以采用 Socket 方式，但是 HTTP 方式不能上传大文件，这里介绍一种通过 Socket 方式来进行断点续传的方式，服务端会记录下文件的上传进度，当某一次上传过程意外终止后，下一次可以继续上传，这里用到的其实还是 J2SE 里的知识。
b)	这个上传程序的原理是：客户端第一次上传时向服务端发送“Content-Length=35;filename=WinRAR_3.90_SC.exe;sourceid=“这种格式的字符串，服务端收到后会查找该文件是否有上传记录，如果有就返回已经上传的位置，否则返回新生成的 sourceid以及 position 为 0，类似 sourceid=2324838389;position=0“这样的字符串，客户端收到返回后的字符串后再从指定的位置开始上传文件。
256.	Android 屏幕适配
257.	1、屏幕适配方式都有哪些
a)	适配方式之 dp
i.	在我们的 Android 工程目录中有如下 drawable-*dpi 目录， 这些目录是用来适配不同分辨率手机的。Android 应用在查找图片资源时会根据其分辨率自动从不同的文件目录下查找（这本身就是Android 系统的适配策略），如果在低分辨的文件目录中比如 drawable-mdpi 中没有图片资源，其他目录中都有，当我们将该应用部署到 mdpi 分辨率的手机上时，那么该应用会查找分辨率较高目录下的资源文件，如果较高分辨率目录下也没有资源则只好找较低目录中的资源了。
b)	适配方式之 dimens
i.	跟 drawable 目录类似的，在 Android 工程的 res 目录下有 values 目录，这个是默认的目录，同时为了适配不同尺寸手机我们可以创建一个 values-1280x720 的文件夹，同时将 dimens.xml 文件拷贝到该目录下。
ii.	我们在 values-1280x720 中放置了 dimens 常量， 一定记得也将该常量的对应值在 values 目录下的dimens.xml 中放一份，因为该文件是默认配置，当用户的手机不是 1280*720 的情况下系统应用使用的是默认 values 目录中的 dimens.xml。
c)	 适配方式之 layout
i.	跟 values 一样，在 Android 工程目录中 layout 目录也支持类似 values 目录一样的适配，在layout 中我们可以针对不同手机的分辨率制定不同的布局。
d)	适配方式之 java 代码适配
e)	 适配方式之 weight 权重适配
i.	在控件中使用属性 android:layout_weight="1"可以起到适配效果，但是该属性的使用有如下规则：
1.	只能用在线性控件中，比如 LinearLayout。
2.	竖直方向上使用权重的控件高度必须为 0dp（Google 官方的推荐用法）
3.	水平方向上使用权重的控件宽度必须为 0dp（Google 官方的推荐用法）
258.	屏幕适配的处理技巧都有哪些
a)	手机自适应主要分为两种情况：横屏和竖屏的切换，以及分辨率大小的不同。
b)	 横屏和竖屏的切换
i.	Android 应用程序支持横竖屏幕的切换，Android 中每次屏幕的切换动会重启 Activity，所以应该在Activity销毁 （执行onPause()方法和onDestroy()方法） 前保存当前活动的状态； 在Activit再次创建的时候载入配置，那样，进行中的游戏就不会自动重启了！有的程序适合从竖屏切换到横屏，或 者 反 过 来 ， 这 个 时 候 怎 么 办 呢 ？ 可 以 在 配 置 Activity 的 地 方 进 行 如 下 的 配 置android:screenOrientation="portrait"（landscape 是横向，portrait 是纵向）。这样就可以保证是竖屏总是竖屏了。
ii.	而有的程序是适合横竖屏切换的。如何处理呢？首先要在配置 Activity 的时候进行如下的配置：android:configChanges="keyboardHidden|orientation" ， 另 外 需 要 重 写 Activity 的onConfigurationChanged 方法。
c)	分辨率大小不同
i.	对于分辨率问题，官方给的解决办法是创建不同的 layout 文件夹，这就需要对每种分辨率的手机都要写一个布局文件，虽然看似解决了分辨率的问题，但是如果其中一处或多处有修改了，就要每个布局文件都要做出修改，这样就造成很大的麻烦。那么可以通过以下几种方式解决：
1.	使用 layout_weight
a)	目前最为推荐的 Android 多屏幕自适应解决方案。
b)	该属性的作用是决定控件在其父布局中的显示权重，一般用于线性布局中。其值越小，则对应的 layout_width 或 layout_height 的优先级就越高（一般到 100 作用就不太明显了）；一般横向布局中，决定的是 layout_width 的优先级；纵向布局中，决定的是 layout_height 的优先级。
c)	传统的 layout_weight 使用方法是将当前控件的 layout_width 和 layout_height 都设置成fill_parent,这样就可以把控件的显示比例完全交给 layout_weight；这样使用的话，就出现了layout_weight 越小，显示比例越大的情况（即权重越大，显示所占的效果越小）。不过对于 2 个控件还好，如果控件过多，且显示比例也不相同的时候，控制起来就比较麻烦了，毕竟反比不是那么好确定的。于是就有了现在最为流行的 0px 设值法。看似让人难以理解的 layout_height=0px 的写法，结合 layout_weight，却可以使控件成正比例显示，轻松解决了当前 Android 开发最为头疼的碎片优化问题之一。
2.	清单文件配置：【不建议使用这种方式，需要对不同的界面写不同的布局】
a)	需要在 AndroidManifest.xml 文件的<manifest>元素如下添加子元素 以上是为我们的屏幕设置多分辨率支持（更准确的说是适配大、中、小三种密度）。
b)	Android:anyDensity="true"，这一句对整个的屏幕都起着十分重要的作用，值为 true，我们的应用程序当安装在不同密度的手机上时，程序会分别加载 hdpi,mdpi,ldpi 文件夹中的资源。相反，如果值设置为 false，即使我们在 hdpi,mdpi,ldpi，xdpi 文件夹下拥有同一种资源，那么应用也不会自动地去相应文件夹下寻找资源。而是会在大密度和小密度手机上加载中密度 mdpi 文件中的资源。
c)	有时候会根据需要在代码中动态地设置某个值， 可以在代码中为这几种密度分别设置偏移量,但是这种方法最好不要使用，最好的方式是在 xml 文件中不同密度的手机进行分别设置。这里地图的偏移量可以在 values-xpdi， values-hpdi,values-mdpi,values-ldpi 四种文件夹中的 dimens.xml 文件进行设置。
3.	其他：
a)	在不同分辨率的手机模拟器下，控件显示的位置会稍有不同。通过在 layout 中定义的布局设置的参数，使用 dp（dip），会根据不同的屏幕分辨率进行适配。但是在代码中的各个参数值，都是使用的像素（px）为单位的
i.	技巧：
1.	尽量使用线性布局，相对布局，如果屏幕放不下了，可以使用 ScrollView（可以上下拖动）
a)	ScrowView 使用的注意：
i.	在不同的屏幕上显示内容不同的情况，其实这个问题我们往往是用滚动视图来解决的，也就是ScrowView；需要注意的是 ScrowView 中使用 layout_weight 是无效的，既然使用 ScrowView 了，就把它里面的控件的大小都设成固定的吧。
2.	指定宽高的时候，采用 dip 的单位，dp 单位动态匹配
3.	由于 android 代码中写的单位都是像素，所有需要通过工具类进行转化
4.	尽量使用 9-patch 图，可以自动的依据图片上面显示的内容被拉伸和收缩。其中在编辑的时候，灰色区域是被拉伸的，上下两个点控制水平方向的拉伸，左右两点控制垂直方向的拉伸
259.	描述一下 android 的系统架构？
a)	 android 系统架构分从下往上为 linux 内核层、运行库、应用程序框架层、和应用程序层。
b)	 linuxkernel：负责硬件的驱动程序、网络、电源、系统安全以及内存管理等功能。
c)	libraries 和 androidruntime：libraries：即 c/c++函数库部分，大多数都是开放源代码的函数库， 例如 webkit， 该函数库负责 android 网页浏览器的运行， 例如标准的 c 函数库 libc、openssl、sqlite 等，当然也包括支持游戏开发 2dsgl 和 3dopengles，在多媒体方面有mediaframework 框架来支持各种影音和图形文件的播放与显示，例如 mpeg4、h.264、mp3、 aac、amr、jpg 和 png 等众多的多媒体文件格式。android 的 runtime 负责解释和执行生成的 dalvik 格式的字节码。
d)	applicationframework（应用软件架构），java 应用程序开发人员主要是使用该层封装好的api 进行快速开发。
e)	applications:该层是 java 的应用程序层，android 内置的 googlemaps、e-mail、即时通信工具、浏览器、mp3 播放 器等处于该层，java 开发人员开发的程序也处于该层，而且和内置的应用程序具有平等的位置，可以调用内置的应用程序，也可以替换内置的应用程序。
260.	事件分发中的 onTouch 和 onTouchEvent 有什么区别，又该如何使用？
a)	这两个方法都是在 View 的 dispatchTouchEvent 中调用的，onTouch 优先于 onTouchEvent执行。如果在 onTouch 方法中通过返回 true 将事件消费掉，onTouchEvent 将不会再执行。
b)	另外需要注意的是，onTouch 能够得到执行需要两个前提条件，第一 mOnTouchListener 的值不能为空，第二当前点击的控件必须是 enable 的。因此如果你有一个控件是非 enable 的，那么给它注册 onTouch 事件将永远得不到执行。对于这一类控件，如果我们想要监听它的 touch 事件，就必须通过在该控件中重写 onTouchEvent 方法来实现。
261.	属性动画，例如一个 button 从 A 移动到 B 点，B 点还是可以响应点击事件，这个原理是什么？
a)	补间动画只是显示的位置变动，View 的实际位置未改变，表现为 View 移动到其他地方，点击事件仍在原处才能响应。而属性动画控件移动后事件相应就在控件移动后本身进行处理
262.	都使用过哪些自定义控件
a)	pull2RefreshListView
b)	LazyViewPager
c)	SlidingMenu
d)	SmoothProgressBar
e)	自定义组合控件
f)	ToggleButton
g)	自定义Toast
263.	谈谈你在工作中是怎样解决一个 bug
a)	异常附近多打印 log 信息；
b)	 分析 log 日志，实在不行的话进行断点调试；
c)	调试不出结果，上 Stack Overflow 贴上异常信息，请教大牛
d)	再多看看代码，或者从源代码中查找相关信息
e)	实在不行就 GG 了，找师傅来解决！
264.	ContentObserver 内容观察者作用及特点
a)	ContentObserver 目的是观察(捕捉)特定 Uri 引起的数据库的变化，继而做一些相应的处理。它类似于数据库技术中的触发器(Trigger)，当 ContentObserver 所观察的 Uri 发生变化时，便会 触 发 它 。 触 发 器 分 为 表 触 发 器 、 行 触 发 器 ， 相 应 地 ContentObserver 也 分 为 “ 表“ContentObserver、“行”ContentObserver，当然这是与它所监听的 Uri MIME Type 有关的。
b)	 注册 ContentObserver 方法：public final void registerContentObserver(Uri uri, boolean notifyForDescendents,ContentObserver observer)
i.	功能：为指定的 Uri 注册一个 ContentObserver 派生类实例，当给定的 Uri 发生改变时，回调该实例对象去处理。
ii.	参数: 
1.	uri 表示需要观察的 Uri
2.	notifyForDescendents 为 false 表示精确匹配，即只匹配该 Uri。 为 true 表示可以同时匹配其派生的 Uri。
c)	取消注册 ContentObserver 方法：public final void unregisterContentObserver(ContentObserver observer)
i.	功能：取消对给定 Uri 的观察
ii.	参数： 
1.	observer ContentObserver 的派生类实例
a)	ContentObserver 类介绍构造方法 ContentObserver(Handler h) void onChange(boolean selfChange) 
i.	功能：当观察到的 Uri 发生变化时，回调该方法去处理。所有 ContentObserver 的派生类都需要重载该方法去处理逻辑。
d)	观察特定 Uri 的步骤如下：
i.	创建我们特定的 ContentObserver 派生类，必须重载父类构造方法，必须重载 onChange()方法去处理回调后的功能实现
1.	利 用 context.getContentResolover() 获 ContentResolover 对 象 ， 接 着 调 用registerContentObserver()方法去注册内容观察者
2.	在不需要时，需要手动的调用 unregisterContentObserver()去取消注册。
265.	开发中都使用过哪些框架、平台
a)	EventBus（事件处理）	
b)	xUtils（网络、图片、ORM）
c)	JPush（推送平台）
d)	友盟（统计平台）
e)	有米（优米）（广告平台）
f)	百度地图
g)	bmob（服务器平台、短信验证、邮箱验证、第三方支付）
h)	阿里云 OSS（云存储）
i)	ShareSDK（分享平台、第三方登录）
j)	Gson（解析 json 数据框架）
k)	imageLoader （图片处理框架）
l)	zxing （二维码扫描）
m)	anroid-asyn-http（网络通讯）
n)	DiskLruCache(硬盘缓存框架)
o)	Viatimo（多媒体播放框架）
p)	universal-image-loader(图片缓存框架)
q)	讯飞语音（语音识别）
266.	谈谈你对 Bitmap 的理解, 什么时候应该手动调用 bitmap.recycle()
a)	Bitmap 是 android 中经常使用的一个类，它代表了一个图片资源。 Bitmap 消耗内存很严重，如果不注意优化代码，经常会出现 OOM 问题，优化方式通常有这么几种： 
i.	使用缓存；
ii.	压缩图片；
iii.	及时回收；
b)	至于什么时候需要手动调用 recycle，这就看具体场景了，原则是当我们不再使用 Bitmap 时，需要回收之。另外，我们需要注意，2.3 之前 Bitmap 对象与像素数据是分开存放的，Bitmap 对象存在java Heap 中而像素数据存放在 Native Memory 中， 这时很有必要调用 recycle 回收内存。 但是 2.3之后，Bitmap 对象和像素数据都是存在 Heap 中，GC 可以回收其内存。
267.	请介绍下 AsyncTask 的内部实现和适用的场景
a)	AsyncTask 内部也是 Handler 机制来完成的，只不过 Android 提供了执行框架来提供线程池来执行相应地任务，因为线程池的大小问题，所以 AsyncTask 只应该用来执行耗时时间较短的任务，比如 HTTP 请求，大规模的下载和数据库的更改不适用于 AsyncTask，因为会导致线程池堵塞，没有线程来执行其他的任务，导致的情形是会发生 AsyncTask 根本执行不了的问题
268.	Android 系统中 GC 什么情况下会出现内存泄露呢？ 
a)	导致内存泄漏主要的原因是，先前申请了内存空间而忘记了释放。如果程序中存在对无用对象的引用，那么这些对象就会驻留内存，消耗内存，因为无法让垃圾回收器 GC 验证这些对象是否不再需要。如果存在对象的引用，这个对象就被定义为"有效的活动"，同时不会被释放。要确定对象所占内存将被回收，我们就要务必确认该对象不再会被使用。典型的做法就是把对象数据成员设为 null 或者从集合中移除该对象。但当局部变量不需要时，不需明显的设为 null，因为一个方法执行完毕时，这些引用会自动被清理。
b)	Java 带垃圾回收的机制,为什么还会内存泄露呢? 
此时，所有的 Object 对象都没有被释放，因为变量 v 引用这些对象。
c)	Java 内存泄露的根本原因就是,保存了不可能再被访问的变量类型的引用
d)	可以使用用检测内存工具：heap
269.	说说 mvc 模式的原理，它在 android 中的运用
a)	模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。
b)	视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个 mvc 架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。
c)	控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新 model 对象状态的部分
d)	View：自定义 View 或 ViewGroup，负责将用户的请求通知 Controller，并根据 model 更新界面；
e)	Controller：Activity 或者 Fragment，接收用户请求并更新 model；
f)	Model：数据模型，负责数据处理相关的逻辑，封装应用程序状态，响应状态查询，通知 View改变，对应 Android 中的 datebase、SharePreference 等。
270.	你一般在开发项目中都使用什么设计模式？如何来重构，优化你的代码？
a)	较为常用的就是单例设计模式，工厂设计模式以及观察者设计模式,
b)	一般需要保证对象在内存中的唯一性时就是用单例模式,例如对数据库操作的 SqliteOpenHelper 的对象。
c)	工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。
d)	观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新
271.	Android 应用中验证码登陆都有哪些实现方案
a)	从服务器端获取图片
b)	通过短信服务，将验证码发送给客户端
272.	定位项目中，如何选取定位方案，如何平衡耗电与实时位置的精度？
a)	开始定位，Application 持有一个全局的公共位置对象，然后隔一定时间自动刷新位置，每次刷新成功都把新的位置信息赋值到全局的位置对象， 然后每个需要使用位置请求的地方都使用全局的位置信息进行请求。 
i.	该方案好处：请求的时候无需再反复定位，每次请求都使用全局的位置对象，节省时间。
ii.	该方案弊端：耗电，每隔一定时间自动刷新位置，对电量的消耗比较大。
b)	按需定位，每次请求前都进行定位。这样做的好处是比较省电，而且节省资源，但是请求时间会变得相对较长。
273.	andorid 应用第二次登录实现自动登录
a)	前置条件是所有用户相关接口都走 https，非用户相关列表类数据走 http。 
b)	步骤
i.	第一次登陆 getUserInfo 里带有一个长效 token，该长效 token 用来判断用户是否登陆和换取短 token 
ii.	把长效 token 保存到 SharedPreferences 
iii.	接口请求用长效 token 换取短token，短 token 服务端可以根据你的接口最后一次请求作为标示，超时时间为一天。
iv.	所有接口都用短效 token 
v.	如果返回短效 token 失效，执行第3步，再直接当前接口 
vi.	如果长效 token 失效（用户换设备或超过一月），提示用户登录。
274.	说说 LruCache 底层原理
a)	LruCache 使用一个 LinkedHashMap 简单的实现内存的缓存，没有软引用，都是强引用。
b)	如果添加的数据大于设置的最大值，就删除最先缓存的数据来调整内存。maxSize 是通过构造方法初始化的值，他表示这个缓存能缓存的最大值是多少。
c)	size 在添加和移除缓存都被更新值， 他通过 safeSizeOf 这个方法更新值。 safeSizeOf 默认返回 1，但一般我们会根据 maxSize 重写这个方法，比如认为 maxSize 代表是 KB 的话，那么就以 KB 为单位返回该项所占的内存大小。
d)	除异常外，首先会判断 size 是否超过 maxSize，如果超过了就取出最先插入的缓存，如果不为空就删掉，并把 size 减去该项所占的大小。这个操作将一直循环下去，直到 size 比 maxSize 小或者缓存为空。
275.	jni 的调用过程?
a)	安装和下载 Cygwin，下载 Android NDK。
b)	ndk 项目中 JNI 接口的设计。
c)	 使用 C/C++实现本地方法。
d)	JNI 生成动态链接库.so 文件。
e)	将动态链接库复制到 java 工程，在 java 工程中调用，运行 java 工程即可。
276.	手机 APP 安全登录的几种方式
a)	一、登录过程的用户认证，常见的手段有密码加密传输、动态密码、验证码等。
i.	密码加密。
1.	目前互联网行业的移动 APP 有不少在使用最简单的做法：根据密码生成一个散列值，把散列值发送给服务器。服务器计算库中用户密码的散列值，然后和客户端传来的散列值比较，一致的话，登录成功。
2.	如果安全性要求更高一些的话，常见的做法就是公钥加密。具体做法是这样，登录前先向服务器请求一个公钥密钥，用公钥密钥加密一串根据密码生成的散列值，然后发送给服务器。服务器使用私钥密钥解密，然后与根据数据库中的用户密码计算出来的散列值进行比较，一致的话，登录成功。当然，还可以做的更优化一些，就是控制公钥密钥的有效期来增强安全性，比如公钥 10 秒钟失效、只能 使 用 一 次 等 。 
ii.	动态密码。
1.	关于动态密码，其本质就是选择另外一种可以识别用户身份唯一性的方式来和用户的静态密码一起 做 用 户 认 证 。 
2.	目前市面上适合 App 使用的最常见的方式是利用手机短信进行动态密码认证。即用户常规登录时，如果服务器发现有异常，可以向用户手机发送一条包含动态密码的短信，用户在有效期（常见的是1分钟）内把用户名、用户密码、动态密码一起发送给服务器进行验证。这个对用户来说，操作门槛比较低，也很方便。
iii.	验证码。
1.	服务器一旦发现登录有异常，如 IP 变化、短时间内登录次数过多等，会向 App 下发一个图片，用户把图片中要求输入的数据和用户名、用户密码一起提交给服务器。为了降低用户登录过程的复杂性，通常情况下，用户只需要输入用户名和密码，只有服务器发现异常情况才会启用验证码、动态密码等机制。
b)	减少用户输入次数的自动登录。
i.	App 登录成功后，服务器会告诉 App 一个 session，后续交流都使用 session。但通常为了安全起见 session 都是要设置有效期的，从 1 星期到 20 天都见过。那么，为了不让用户在 session 失效后重新登录，减少用户的手动输入用户名和用户密码的次数，引入了“自动登录”概念。流程如下：
1.	登录成功后，服务器给 App 下发 sesion 的同时，还下发一个认证 token，客户端把 token 做为应用程序的私有数据存储起来。以后，每当 session 过期后，就把 token 发送给服务器获取新的session。整个过程都是对用户透明的，对用户来说，输入一次用户名和密码后，就再也没有登录这个事情了。
2.	当然，这种自动登录的前提，是能保证 token 的安全性远大于 session。我们知道，由于手机OS的安全机制，token 做为应用程序的私有数据，对其它应用是不可见的，可以保证 token 的安全性。我们还可以再上一个锁，把 token 和用户使用 App 的那个设备做绑定。可供选择的绑定数据有imsi,mac 等。这样的话，只要用户手机不丢，就没事。
c)	没有一种安全机制是绝对安全的，我们需要在实际应用过程中综合运用 App 使用场景、具体业务类型、用户习惯等各种方式来平衡安全性、用户体验还有商业应用中很重要的成本。
277.	设计模式六大原则
a)	单一职责原则:不要存在多于一个导致类变更的原因。
i.	通俗的说:即一个类只负责一项职责。
b)	里氏替换原则:所有引用基类的地方必须能透明地使用其子类的对象。
i.	通俗的说:当使用继承时。类 B 继承类 A 时，除添加新的方法完成新增功能 P2外，尽量不要重写父类 A的方法， 也尽量不要重载父类 A 的方法。 如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。子类可以扩展父类的功能，但不能改变父类原有的功能。
c)	.依赖倒置原则:高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。
i.	通俗的说:在 java 中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。依赖倒置原则的核心思想是面向接口编程.
d)	接口隔离原则:客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。
i.	通俗的说:建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。
e)	迪米特法则:一个对象应该对其他对象保持最少的了解
i.	通俗的说:尽量降低类与类之间的耦合。
f)	开闭原则:一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
i.	通俗的说:用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。
278.	即时通讯是是怎么做的?
a)	使用asmark 开源框架实现的即时通讯功能.该框架基于开源的 XMPP 即时通信协议，采用 C／S 体系结构，通过 GPRS 无线网络用 TCP 协议连接到服务器，以架设开源的Openfn'e 服务器作为即时通讯平台。
b)	客户端基于 Android 平台进行开发。负责初始化通信过程，进行即时通信时，由客户端负责向服务器发起创建连接请求。系统通过 GPRS 无线网络与 Internet 网络建立连接，通过服务器实现与Android 客户端的即时通信脚。
c)	服务器端则采用 Openfire 作为服务器。 允许多个客户端同时登录并且并发的连接到一个服务器上。服务器对每个客户端的连接进行认证，对认证通过的客户端创建会话，客户端与服务器端之间的通信就在该会话的上下文中进行。
279.	怎样对 android 进行优化？
a)	对 listview 的优化。
b)	 对图片的优化。
c)	对内存的优化。
d)	具体一些措施
i.	尽量不要使用过多的静态类 static
ii.	数据库使用完成后要记得关闭 cursor
iii.	广播使用完之后要注销
